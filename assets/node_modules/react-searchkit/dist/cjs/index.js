Object.defineProperty(exports, '__esModule', { value: true });

var _isEmpty = require('lodash/isEmpty');
var axios = require('axios');
var _get$1 = require('lodash/get');
var _hasIn = require('lodash/hasIn');
var Qs = require('qs');
var _extend = require('lodash/extend');
var _head = require('lodash/head');
var _isArray = require('lodash/isArray');
var _pick = require('lodash/pick');
var _cloneDeep = require('lodash/cloneDeep');
var _isBoolean = require('lodash/isBoolean');
var _isObject = require('lodash/isObject');
var _isString = require('lodash/isString');
var _isNumber = require('lodash/isNumber');
var reactRedux = require('react-redux');
var React = require('react');
var Overridable = require('react-overridable');
var semanticUiReact = require('semantic-ui-react');
var redux = require('redux');
var thunk = require('redux-thunk');
var _ = require('lodash');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(_isEmpty);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get$1);
var _hasIn__default = /*#__PURE__*/_interopDefaultLegacy(_hasIn);
var Qs__default = /*#__PURE__*/_interopDefaultLegacy(Qs);
var _extend__default = /*#__PURE__*/_interopDefaultLegacy(_extend);
var _head__default = /*#__PURE__*/_interopDefaultLegacy(_head);
var _isArray__default = /*#__PURE__*/_interopDefaultLegacy(_isArray);
var _pick__default = /*#__PURE__*/_interopDefaultLegacy(_pick);
var _cloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(_cloneDeep);
var _isBoolean__default = /*#__PURE__*/_interopDefaultLegacy(_isBoolean);
var _isObject__default = /*#__PURE__*/_interopDefaultLegacy(_isObject);
var _isString__default = /*#__PURE__*/_interopDefaultLegacy(_isString);
var _isNumber__default = /*#__PURE__*/_interopDefaultLegacy(_isNumber);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var Overridable__default = /*#__PURE__*/_interopDefaultLegacy(Overridable);
var thunk__default = /*#__PURE__*/_interopDefaultLegacy(thunk);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var ESRequestSerializer = /*#__PURE__*/function () {
  function ESRequestSerializer() {
    _classCallCheck(this, ESRequestSerializer);
    this.serialize = this.serialize.bind(this);
  }

  /**
   * Return a serialized version of the app state `query` for the API backend.
   * @param {object} stateQuery the `query` state to serialize
   */
  _createClass(ESRequestSerializer, [{
    key: "serialize",
    value: function serialize(stateQuery) {
      var queryString = stateQuery.queryString,
        sortBy = stateQuery.sortBy,
        sortOrder = stateQuery.sortOrder,
        page = stateQuery.page,
        size = stateQuery.size;
      var bodyParams = {};
      if (!_isEmpty__default["default"](queryString)) {
        bodyParams["query"] = {
          query_string: {
            query: queryString
          }
        };
      }
      if (sortBy) {
        var sortObj = {};
        sortObj[sortBy] = sortOrder && sortOrder === "desc" ? "desc" : "asc";
        bodyParams["sort"] = sortObj;
      }
      if (size > 0) {
        bodyParams["size"] = size;
      }
      if (page > 0) {
        var s = size > 0 ? size : 0;
        var from = (page - 1) * s;
        bodyParams["from"] = from;
      }
      return bodyParams;
    }
  }]);
  return ESRequestSerializer;
}();

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var ESResponseSerializer = /*#__PURE__*/function () {
  function ESResponseSerializer() {
    _classCallCheck(this, ESResponseSerializer);
    this.serialize = this.serialize.bind(this);
  }

  /**
   * Return a serialized version of the API backend response for the app state `results`.
   * @param {object} payload the backend response payload
   */
  _createClass(ESResponseSerializer, [{
    key: "serialize",
    value: function serialize(payload) {
      var aggregations = payload.aggregations,
        hits = payload.hits;
      return {
        aggregations: aggregations || {},
        hits: hits.hits.map(function (hit) {
          return hit._source;
        }),
        total: hits.total.value
      };
    }
  }]);
  return ESResponseSerializer;
}();

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _regeneratorRuntime() {
  _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) {
              if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            }
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
        "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      }
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

/**
 * Custom errors to raise specific expcetions
 */

function RequestCancelledError() {}
RequestCancelledError.prototype = new Error();

var ESSearchApi = /*#__PURE__*/function () {
  function ESSearchApi(config) {
    _classCallCheck(this, ESSearchApi);
    this.axiosConfig = _get__default["default"](config, "axios", {});
    this.validateAxiosConfig();
    this.initSerializers(config);
    this.initInterceptors(config);
    this.initAxios();
    this.search = this.search.bind(this);
    this.axiosCancelToken = axios__default["default"].CancelToken;
  }
  _createClass(ESSearchApi, [{
    key: "validateAxiosConfig",
    value: function validateAxiosConfig() {
      if (!_hasIn__default["default"](this.axiosConfig, "url")) {
        throw new Error("ESSearchApi config: `node` field is required.");
      }
    }
  }, {
    key: "initInterceptors",
    value: function initInterceptors(config) {
      this.requestInterceptor = _get__default["default"](config, "interceptors.request", undefined);
      this.responseInterceptor = _get__default["default"](config, "interceptors.response", undefined);
    }
  }, {
    key: "initSerializers",
    value: function initSerializers(config) {
      var requestSerializerCls = _get__default["default"](config, "es.requestSerializer", ESRequestSerializer);
      var responseSerializerCls = _get__default["default"](config, "es.responseSerializer", ESResponseSerializer);
      this.requestSerializer = new requestSerializerCls();
      this.responseSerializer = new responseSerializerCls();
    }
  }, {
    key: "initAxios",
    value: function initAxios() {
      this.http = axios__default["default"].create(this.axiosConfig);
      this.addInterceptors();
    }
  }, {
    key: "addInterceptors",
    value: function addInterceptors() {
      if (this.requestInterceptor) {
        this.http.interceptors.request.use(this.requestInterceptor.resolve, this.requestInterceptor.reject);
      }
      if (this.responseInterceptor) {
        this.http.interceptors.request.use(this.responseInterceptor.resolve, this.responseInterceptor.reject);
      }
    }

    /**
     * Perform the backend request to search and return the serialized list of results for the app state `results`.
     * @param {string} stateQuery the `query` state with the user input
     */
  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(stateQuery) {
        var payload, response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // cancel any previous request in case it is still happening
                this.axiosCancel && this.axiosCancel.cancel();
                // generate a new cancel token for this request
                this.axiosCancel = this.axiosCancelToken.source();
                payload = this.requestSerializer.serialize(stateQuery);
                _context.prev = 3;
                _context.next = 6;
                return this.http.request({
                  url: this.axiosConfig.url,
                  method: "POST",
                  data: payload,
                  cancelToken: this.axiosCancel.token
                });
              case 6:
                response = _context.sent;
                return _context.abrupt("return", this.responseSerializer.serialize(response.data));
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](3);
                if (!axios__default["default"].isCancel(_context.t0)) {
                  _context.next = 16;
                  break;
                }
                throw new RequestCancelledError();
              case 16:
                throw _context.t0;
              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 10]]);
      }));
      function search(_x) {
        return _search.apply(this, arguments);
      }
      return search;
    }()
  }]);
  return ESSearchApi;
}();

/** Default backend request serializer */
var InvenioRequestSerializer = /*#__PURE__*/function () {
  function InvenioRequestSerializer() {
    var _this = this;
    _classCallCheck(this, InvenioRequestSerializer);
    this._addFilter = function (filter, filterUrlParams) {
      if (!Array.isArray(filter)) {
        throw new Error("Filter value \"".concat(filter, "\" in query state must be an array."));
      }
      if (!(filter.length === 2 || filter.length === 3)) {
        throw new Error("Filter value \"".concat(filter, "\" in query state must be an array of 2 or 3 elements"));
      }
      var aggName = filter[0];
      var fieldValue = filter[1];
      if (aggName in filterUrlParams) {
        filterUrlParams[aggName].push(fieldValue);
      } else {
        filterUrlParams[aggName] = [fieldValue];
      }
      var hasChild = filter.length === 3;
      if (hasChild) {
        _this._addFilter(filter[2], filterUrlParams);
      }
    };
    this._addFilters = function (filters) {
      if (!Array.isArray(filters)) {
        throw new Error("Filters query state \"".concat(filters, "\" must be an array."));
      }
      /**
       * input: [
       *   [ 'type_agg', 'value1' ]
       *   [ 'type_agg', 'value2', [ 'subtype_agg', 'a value' ] ]
       * ]
       */
      var filterUrlParams = {};
      filters.forEach(function (filter) {
        _this._addFilter(filter, filterUrlParams);
      });
      /**
       * output: {
       *  type_agg: 'value1'.
       *  subtype_agg: 'a value'
       * }
       */
      return filterUrlParams;
    };
    this.serialize = this.serialize.bind(this);
  }
  _createClass(InvenioRequestSerializer, [{
    key: "serialize",
    value:
    /**
     * Return a serialized version of the app state `query` for the API backend.
     * @param {object} stateQuery the `query` state to serialize
     */
    function serialize(stateQuery) {
      var queryString = stateQuery.queryString,
        sortBy = stateQuery.sortBy,
        sortOrder = stateQuery.sortOrder,
        page = stateQuery.page,
        size = stateQuery.size,
        filters = stateQuery.filters,
        hiddenParams = stateQuery.hiddenParams;
      var getParams = {};
      if (queryString !== null) {
        getParams["q"] = queryString;
      }
      if (sortBy !== null) {
        getParams["sort"] = sortBy;
        if (sortOrder !== null) {
          getParams["sort"] = sortOrder === "desc" ? "-".concat(sortBy) : sortBy;
        }
      }
      if (page > 0) {
        getParams["page"] = page;
      }
      if (size > 0) {
        getParams["size"] = size;
      }
      if (!_isEmpty__default["default"](hiddenParams)) {
        _extend__default["default"](getParams, this._addFilters(hiddenParams));
      }
      var filterParams = this._addFilters(filters);
      _extend__default["default"](getParams, filterParams);
      return Qs__default["default"].stringify(getParams, {
        arrayFormat: "repeat"
      });
    }
  }]);
  return InvenioRequestSerializer;
}();

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var _excluded$4 = ["aggregations", "hits"];
/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

/** Default backend response serializer */
var InvenioResponseSerializer = /*#__PURE__*/function () {
  function InvenioResponseSerializer() {
    _classCallCheck(this, InvenioResponseSerializer);
    this.serialize = this.serialize.bind(this);
  }

  /**
   * Return a serialized version of the API backend response for the app state `results`.
   * @param {object} payload the backend response payload
   */
  _createClass(InvenioResponseSerializer, [{
    key: "serialize",
    value: function serialize(payload) {
      var aggregations = payload.aggregations,
        hits = payload.hits,
        extras = _objectWithoutProperties(payload, _excluded$4);
      return {
        aggregations: aggregations || {},
        hits: hits.hits,
        total: hits.total,
        extras: extras
      };
    }
  }]);
  return InvenioResponseSerializer;
}();

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

/**
 * Return true if the first string starts and contains the second.
 * @param {string} first a string
 * @param {string} second a string
 */
function startsWith(first, second) {
  return first.indexOf(second) === 0;
}
function toString(array) {
  return Qs__default["default"].stringify({
    q: array
  });
}
function parse(str) {
  return Qs__default["default"].parse(str)["q"];
}
function removeLastChild(arr) {
  var hasChild = arr.length === 3;
  if (hasChild) {
    var result = [arr[0], arr[1]];
    var lastChild = removeLastChild(arr[2]);
    if (lastChild.length) {
      result.push(lastChild);
    }
    return result;
  }
  return [];
}
function updateFilter(queryFilter, stateFilters) {
  /**
   * convert query and state to strings so they can be compared
   */
  var strQuery = toString(queryFilter);
  var strStateFilters = stateFilters.map(function (stateObjQuery) {
    return toString(stateObjQuery);
  });

  /**
   * filter out any state that starts with the query or any parent of the query
   * e.g. query = ['file_type', 'pdf']
   *      state = [[ 'file_type', 'pdf' ]]
   *      filtered = []
   *
   *      query = [ 'type', 'publication' ]
   *      state = [['type', 'publication', ['subtype', 'report' ]]
   *      filtered = []
   *
   *      query = ['type', 'publication', ['subtype', 'report']]]
   *      state = [[ 'type', 'publication' ]]
   *      filtered = []
   */
  var anyRemoved = false;
  var filteredStrStates = strStateFilters.filter(function (strStateFilter) {
    var childFilterExists = startsWith(strStateFilter, strQuery);
    var parentFilterExists = startsWith(strQuery, strStateFilter);
    if (childFilterExists && !anyRemoved) {
      anyRemoved = true;
    }
    return !childFilterExists && !parentFilterExists;
  });
  if (!anyRemoved) {
    /**
     * if nothing has been removed, it means it was not previously there, so
     * the user query has to be added.
     * e.g. query = ['type', 'publication', ['subtype', 'report']]
     *      state = []
     *      filtered = [['type', 'publication', ['subtype', 'report']]]
     */
    filteredStrStates.push(strQuery);
  } else {
    /**
     * if a filter has been removed, it might have been a child. Add its parent if it is the root parent.
     * e.g. query = ['type', 'publication', 'subtype', 'report']
     *      state = [['type', 'publication', ['subtype', 'report']]]
     *      filtered = [['type', 'publication']]
     */
    var hasChild = queryFilter.length === 3;
    if (hasChild) {
      var rootParentArr = removeLastChild(queryFilter);
      var rootParentArrStrQuery = toString(rootParentArr);
      var anotherChildFound = filteredStrStates.some(function (strStateFilter) {
        var childFilterExists = startsWith(strStateFilter, rootParentArrStrQuery);
        var parentFilterExists = startsWith(rootParentArrStrQuery, strStateFilter);
        return childFilterExists || parentFilterExists;
      });
      if (_isEmpty__default["default"](filteredStrStates) || !anotherChildFound) {
        filteredStrStates.push(rootParentArrStrQuery);
      }
    }
  }

  /**
   * convert back to lists
   */
  return filteredStrStates.map(function (strState) {
    return parse(strState);
  });
}
var updateQueryFilters$1 = function updateQueryFilters(queryFilter, stateFilters) {
  if (_isEmpty__default["default"](queryFilter)) return;

  /** If we have one filter as query = ['file_type', 'pdf'] */
  if (!_isArray__default["default"](_head__default["default"](queryFilter))) {
    return updateFilter(queryFilter, stateFilters);
  }

  /** If we have an array of filters as query we apply the filters one by one.
   * e.g. query = [['file_type', 'pdf'], ['file_type', 'txt']]
   */
  var tempStateFilters = stateFilters;
  var _iterator = _createForOfIteratorHelper(queryFilter),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var filter = _step.value;
      tempStateFilters = updateFilter(filter, tempStateFilters);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return tempStateFilters;
};
var updateQueryState$1 = function updateQueryState(oldState, newState, storeKeys) {
  var pickedState = _pick__default["default"](newState, storeKeys);
  if (!_isEmpty__default["default"](pickedState.filters)) {
    pickedState["filters"] = updateQueryFilters$1(pickedState.filters, oldState.filters);
  }
  return pickedState;
};

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var INITIAL_QUERY_STATE = {
  queryString: "",
  suggestions: [],
  sortBy: null,
  sortOrder: null,
  page: -1,
  size: -1,
  filters: [],
  hiddenParams: [],
  layout: null
};
var INITIAL_QUERY_STATE_KEYS = Object.keys(INITIAL_QUERY_STATE);
var INITIAL_RESULTS_STATE = {
  loading: false,
  data: {
    hits: [],
    total: 0,
    aggregations: {}
  },
  error: {}
};
var INITIAL_APP_STATE = {
  hasUserChangedSorting: false,
  initialSortBy: null,
  initialSortOrder: null
};

/** Default backend request serializer for invenio-records-resources */
var InvenioRecordsResourcesRequestSerializer = /*#__PURE__*/function () {
  function InvenioRecordsResourcesRequestSerializer() {
    var _this = this;
    _classCallCheck(this, InvenioRecordsResourcesRequestSerializer);
    this._checkFilter = function (filter) {
      if (!Array.isArray(filter)) {
        throw new Error("Filter value \"".concat(filter, "\" in query state must be an array."));
      }
      if (!(filter.length === 2 || filter.length === 3)) {
        throw new Error("Filter value \"".concat(filter, "\" in query state must be an array of 2 or 3 elements"));
      }
    };
    this._addFilter = function (filter, filterUrlParams) {
      _this._checkFilter(filter);
      var aggName = filter[0];
      var fieldValue = filter[1];
      var hasChild = filter.length === 3;
      if (hasChild) {
        _this._checkFilter(filter[2]);
      }
      if (aggName in filterUrlParams) {
        if (hasChild) {
          filterUrlParams[aggName].push(fieldValue + "::" + filter[2][1]);
        } else {
          filterUrlParams[aggName].push(fieldValue);
        }
      } else {
        if (hasChild) {
          filterUrlParams[aggName] = [fieldValue + "::" + filter[2][1]];
        } else {
          filterUrlParams[aggName] = [fieldValue];
        }
      }
    };
    this._addFilters = function (filters) {
      if (!Array.isArray(filters)) {
        throw new Error("Filters query state \"".concat(filters, "\" must be an array."));
      }
      /**
       * input: [
       *   [ 'type_agg', 'value1' ]
       *   [ 'type_agg', 'value2', [ 'subtype_agg', 'a value' ] ]
       * ]
       */
      var filterUrlParams = {};
      filters.forEach(function (filter) {
        _this._addFilter(filter, filterUrlParams);
      });
      /**
       * output: {
       *  type_agg: ['value1', 'value2::a value']
       * }
       */

      return filterUrlParams;
    };
    this.serialize = this.serialize.bind(this);
  }
  _createClass(InvenioRecordsResourcesRequestSerializer, [{
    key: "serialize",
    value:
    /**
     * Return a serialized version of the app state `query` for the API backend.
     * @param {object} stateQuery the `query` state to serialize
     */
    function serialize(stateQuery) {
      var queryString = stateQuery.queryString,
        sortBy = stateQuery.sortBy,
        sortOrder = stateQuery.sortOrder,
        page = stateQuery.page,
        size = stateQuery.size,
        filters = stateQuery.filters,
        hiddenParams = stateQuery.hiddenParams;
      var getParams = {};
      if (queryString !== null) {
        getParams["q"] = queryString;
      }
      if (sortBy !== null) {
        getParams["sort"] = sortBy;
        if (sortOrder !== null) {
          getParams["sort"] = sortOrder === "desc" ? "-".concat(sortBy) : sortBy;
        }
      }
      if (page > 0) {
        getParams["page"] = page;
      }
      if (size > 0) {
        getParams["size"] = size;
      }
      if (!_isEmpty__default["default"](hiddenParams)) {
        _extend__default["default"](getParams, this._addFilters(hiddenParams));
      }
      var filterParams = this._addFilters(filters);
      _extend__default["default"](getParams, filterParams);
      return Qs__default["default"].stringify(getParams, {
        arrayFormat: "repeat"
      });
    }
  }]);
  return InvenioRecordsResourcesRequestSerializer;
}();

var InvenioSearchApi = /*#__PURE__*/function () {
  function InvenioSearchApi(config) {
    _classCallCheck(this, InvenioSearchApi);
    this.axiosConfig = _get__default["default"](config, "axios", {});
    this.validateAxiosConfig();
    this.initSerializers(config);
    this.initInterceptors(config);
    this.initAxios();
    this.search = this.search.bind(this);
    this.axiosCancelToken = axios__default["default"].CancelToken;
  }
  _createClass(InvenioSearchApi, [{
    key: "validateAxiosConfig",
    value: function validateAxiosConfig() {
      if (!_hasIn__default["default"](this.axiosConfig, "url")) {
        throw new Error("InvenioSearchApi config: `url` field is required.");
      }
    }
  }, {
    key: "initInterceptors",
    value: function initInterceptors(config) {
      this.requestInterceptor = _get__default["default"](config, "interceptors.request", undefined);
      this.responseInterceptor = _get__default["default"](config, "interceptors.response", undefined);
    }
  }, {
    key: "getSerializer",
    value: function getSerializer(serializer) {
      var requestSerializerMap = {
        InvenioRecordsResourcesRequestSerializer: InvenioRecordsResourcesRequestSerializer,
        InvenioRequestSerializer: InvenioRequestSerializer
      };
      if (typeof serializer === "string") {
        return requestSerializerMap[serializer];
      } else {
        return serializer ? serializer : InvenioRequestSerializer;
      }
    }
  }, {
    key: "initSerializers",
    value: function initSerializers(config) {
      var _config$invenio;
      var requestSerializerCls = this.getSerializer((_config$invenio = config.invenio) === null || _config$invenio === void 0 ? void 0 : _config$invenio.requestSerializer);
      var responseSerializerCls = _get__default["default"](config, "invenio.responseSerializer", InvenioResponseSerializer);
      this.requestSerializer = new requestSerializerCls();
      this.responseSerializer = new responseSerializerCls();
    }
  }, {
    key: "initAxios",
    value: function initAxios() {
      var axiosConfig = _objectSpread2({
        paramsSerializer: this.requestSerializer.serialize
      }, this.axiosConfig);
      this.http = axios__default["default"].create(axiosConfig);
      this.addInterceptors();
    }
  }, {
    key: "addInterceptors",
    value: function addInterceptors() {
      if (this.requestInterceptor) {
        this.http.interceptors.request.use(this.requestInterceptor.resolve, this.requestInterceptor.reject);
      }
      if (this.responseInterceptor) {
        this.http.interceptors.request.use(this.responseInterceptor.resolve, this.responseInterceptor.reject);
      }
    }

    /**
     * Perform the backend request to search and return the serialized list of results for the app state `results`.
     * @param {string} stateQuery the `query` state with the user input
     */
  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(stateQuery) {
        var response, newQueryState;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // cancel any previous request in case it is still happening
                this.axiosCancel && this.axiosCancel.cancel();
                // generate a new cancel token for this request
                this.axiosCancel = this.axiosCancelToken.source();
                _context.prev = 2;
                _context.next = 5;
                return this.http.request({
                  url: this.axiosConfig.url,
                  params: stateQuery,
                  cancelToken: this.axiosCancel.token
                });
              case 5:
                response = _context.sent;
                response = this.responseSerializer.serialize(response.data);
                newQueryState = updateQueryState$1(stateQuery, response.extras, INITIAL_QUERY_STATE_KEYS);
                if (!_isEmpty__default["default"](newQueryState)) {
                  response.newQueryState = newQueryState;
                }
                delete response.extras;
                return _context.abrupt("return", response);
              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](2);
                if (!axios__default["default"].isCancel(_context.t0)) {
                  _context.next = 19;
                  break;
                }
                throw new RequestCancelledError();
              case 19:
                throw _context.t0;
              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 13]]);
      }));
      function search(_x) {
        return _search.apply(this, arguments);
      }
      return search;
    }()
  }]);
  return InvenioSearchApi;
}();

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

var InvenioSuggestionRequestSerializer = /*#__PURE__*/function () {
  function InvenioSuggestionRequestSerializer(queryField) {
    _classCallCheck(this, InvenioSuggestionRequestSerializer);
    this.queryField = queryField;
    this.serialize = this.serialize.bind(this);
  }

  /**
   * Return a serialized version of the app state `query` for the API backend.
   * @param {object} stateQuery the `query` state to serialize
   */
  _createClass(InvenioSuggestionRequestSerializer, [{
    key: "serialize",
    value: function serialize(stateQuery) {
      var suggestionString = stateQuery.suggestionString;
      var getParams = {};
      if (suggestionString !== null) {
        getParams["q"] = this.queryField + ":" + suggestionString;
      }
      return Qs__default["default"].stringify(getParams, {
        arrayFormat: "repeat",
        encode: false
      });
    }
  }]);
  return InvenioSuggestionRequestSerializer;
}();
var InvenioSuggestionResponseSerializer = /*#__PURE__*/function () {
  function InvenioSuggestionResponseSerializer(responseField) {
    var _this = this;
    _classCallCheck(this, InvenioSuggestionResponseSerializer);
    this._serializeSuggestions = function (responseHits) {
      return Array.from(new Set(responseHits.map(function (hit) {
        return _get__default["default"](hit.metadata, _this.responseFieldPath);
      })));
    };
    this.responseFieldPath = responseField.split(".");
    this.serialize = this.serialize.bind(this);
  }
  _createClass(InvenioSuggestionResponseSerializer, [{
    key: "serialize",
    value:
    /**
     * Return a serialized version of the API backend response for the app state `suggestions`.
     * @param {object} payload the backend response payload
     */
    function serialize(payload) {
      return {
        suggestions: this._serializeSuggestions(payload.hits.hits || [])
      };
    }
  }]);
  return InvenioSuggestionResponseSerializer;
}();
var InvenioSuggestionApi = /*#__PURE__*/function (_InvenioSearchApi) {
  _inherits(InvenioSuggestionApi, _InvenioSearchApi);
  var _super = _createSuper(InvenioSuggestionApi);
  function InvenioSuggestionApi() {
    _classCallCheck(this, InvenioSuggestionApi);
    return _super.apply(this, arguments);
  }
  _createClass(InvenioSuggestionApi, [{
    key: "validateConfig",
    value: function validateConfig(config) {
      _get(_getPrototypeOf(InvenioSuggestionApi.prototype), "validateConfig", this).call(this, config);
      if (!_hasIn__default["default"](config, "invenio.suggestions.queryField")) {
        throw new Error("InvenioSuggestionApi config: `invenio.suggestions.queryField` is required.");
      }
      if (!_hasIn__default["default"](config, "invenio.suggestions.responseField")) {
        throw new Error("InvenioSuggestionApi config: `invenio.suggestions.queryField` is responseField.");
      }
    }
  }, {
    key: "initSerializers",
    value: function initSerializers(config) {
      var requestSerializerCls = _get__default["default"](config, "invenio.requestSerializer", InvenioSuggestionRequestSerializer);
      var responseSerializerCls = _get__default["default"](config, "invenio.responseSerializer", InvenioSuggestionResponseSerializer);
      this.requestSerializer = new requestSerializerCls(config.invenio.suggestions.queryField);
      this.responseSerializer = new responseSerializerCls(config.invenio.suggestions.responseField);
    }
  }]);
  return InvenioSuggestionApi;
}(InvenioSearchApi);

/** Default implementation for a param validator class */
var UrlParamValidator = /*#__PURE__*/_createClass(function UrlParamValidator() {
  _classCallCheck(this, UrlParamValidator);
  this.isValid = function (urlHandler, key, value) {
    switch (key) {
      case "queryString":
      case "sortBy":
        return true;
      case "sortOrder":
        return ["asc", "desc"].includes(value);
      case "page":
      case "size":
        return _isNumber__default["default"](value) && value > 0;
      case "layout":
        return ["grid", "list"].includes(value);
      case "filters":
      case "hiddenParams":
        {
          var array = _isArray__default["default"](value) ? value : [value];
          var cKvSep = ":",
            cChildSep = urlHandler.urlFilterSeparator;
          var pLiteral = "[^\\".concat(cKvSep, "\\").concat(cChildSep, "]*"),
            pKeyValue = "".concat(pLiteral, "\\").concat(cKvSep).concat(pLiteral),
            pAll = "".concat(pKeyValue, "(\\").concat(cChildSep).concat(pKeyValue, ")*");
          var regex = new RegExp("^".concat(pAll, "$"));
          return array.every(function (filter) {
            return String(filter).match(regex);
          });
        }
      default:
        return false;
    }
  };
});

var pushHistory = function pushHistory(query) {
  if (window.history.pushState) {
    window.history.pushState({
      path: query
    }, "", query);
  }
};
var replaceHistory = function replaceHistory(query) {
  if (window.history.replaceState) {
    window.history.replaceState({
      path: query
    }, "", query);
  }
};

/** Default URL parser implementation */
var UrlParser = /*#__PURE__*/function () {
  function UrlParser() {
    var _this = this;
    _classCallCheck(this, UrlParser);
    this._convertValue = function (key, value) {
      switch (key) {
        case _this.paramsMapping["page"]:
        case _this.paramsMapping["size"]:
          return parseInt(value);
        default:
          return value;
      }
    };
    this.parse = this.parse.bind(this);
    this.paramsMapping = {};
  }
  _createClass(UrlParser, [{
    key: "urlParamsMapping",
    set: function set(mapping) {
      this.paramsMapping = mapping;
    }

    /**
     * Convert string to int for `page` and `size` params
     * @param {string} key the name of the param
     * @param {string} value the value of the param
     */
  }, {
    key: "parse",
    value:
    /**
     * Parse the URL query string and return an object with all the params.
     * @param {string} queryString the query string to parse
     */
    function parse() {
      var _this2 = this;
      var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var parsedParams = Qs__default["default"].parse(queryString, {
        ignoreQueryPrefix: true
      });
      var params = {};
      Object.entries(parsedParams).forEach(function (entry) {
        var key = entry[0];
        var value = entry[1];
        params[key] = _this2._convertValue(key, value);
      });
      return params;
    }
  }]);
  return UrlParser;
}(); /** Object responsible to update the URL query string and parse it to update the app state */
var UrlHandlerApi = /*#__PURE__*/function () {
  function UrlHandlerApi() {
    var _this3 = this;
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, UrlHandlerApi);
    this._filterListToString = function (filter) {
      var childFilter = filter.length === 3 ? _this3.urlFilterSeparator.concat(_this3._filterListToString(filter[2])) : "";
      return "".concat(filter[0], ":").concat(filter[1]).concat(childFilter);
    };
    this._mapQueryStateToUrlParams = function (queryState) {
      var params = {};
      Object.keys(queryState).filter(function (stateKey) {
        return stateKey in _this3.urlParamsMapping;
      }).filter(function (stateKey) {
        // filter out negative or null values
        if ((stateKey === "page" || stateKey === "size") && queryState[stateKey] <= 0) {
          return false;
        }
        if (stateKey === "hiddenParams") {
          return false;
        }
        return queryState[stateKey] !== null;
      }).forEach(function (stateKey) {
        var paramKey = _this3.urlParamsMapping[stateKey];
        if (stateKey === "filters") {
          params[paramKey] = queryState[stateKey].map(function (filter) {
            return _this3._filterListToString(filter);
          });
        } else {
          params[paramKey] = queryState[stateKey];
        }
      });
      var keyComparator = function keyComparator(a, b) {
        var q = "q"; // query parameter should appear first
        if (a === q) {
          return -1;
        } else if (b === q) {
          return 1;
        }
        return a.localeCompare(b);
      };

      // will omit undefined and null values from the query
      return Qs__default["default"].stringify(params, {
        addQueryPrefix: true,
        skipNulls: true,
        indices: false,
        // order for filters params is not important, remove indices
        sort: keyComparator
      });
    };
    this._filterStringToList = function (filterStr) {
      var childSepPos = filterStr.indexOf(_this3.urlFilterSeparator);
      var hasChild = childSepPos > -1;
      var aggNamePos = filterStr.indexOf(":");
      if (aggNamePos === -1) {
        throw new Error("Filter \"".concat(filterStr, "\" not parsable. Format expected: \"<agg name>:<value>\""));
      }
      var aggName = filterStr.slice(0, aggNamePos);
      var end = hasChild ? childSepPos : filterStr.length;
      var value = filterStr.slice(aggNamePos + 1, end);
      var filterList = [aggName, value];
      if (hasChild) {
        var childFilter = filterStr.slice(childSepPos + 1, filterStr.length);
        filterList.push(_this3._filterStringToList(childFilter));
      }
      return filterList;
    };
    this._mapUrlParamsToQueryState = function (urlParamsObj) {
      var result = {};
      Object.keys(urlParamsObj).forEach(function (paramKey) {
        var queryStateKey = _this3.fromUrlParamsMapping[paramKey];
        if (_this3.urlParamValidator.isValid(_this3, queryStateKey, urlParamsObj[paramKey])) {
          result[queryStateKey] = urlParamsObj[paramKey];
          // custom transformation for filters
          if (queryStateKey === "filters") {
            if (!Array.isArray(urlParamsObj[paramKey])) {
              // if only 1 filter, create an array with one element
              urlParamsObj[paramKey] = [urlParamsObj[paramKey]];
            }
            result[queryStateKey] = urlParamsObj[paramKey].map(function (filter) {
              return _this3._filterStringToList(filter);
            });
          }
        } else {
          console.warn("URL parameter '".concat(paramKey, "' with value '").concat(urlParamsObj[paramKey], "' is incorrect and was ignored."));
        }
      });
      return result;
    };
    this._mergeParamsIntoState = function (urlStateObj, queryState) {
      var _queryState = _cloneDeep__default["default"](queryState);
      Object.keys(urlStateObj).forEach(function (stateKey) {
        _queryState[stateKey] = urlStateObj[stateKey];
      });
      return _queryState;
    };
    this.urlParamsMapping = _isObject__default["default"](config.urlParamsMapping) ? config.urlParamsMapping : {
      queryString: "q",
      sortBy: "sort",
      sortOrder: "order",
      page: "p",
      size: "s",
      layout: "l",
      filters: "f",
      hiddenParams: "hp"
    };
    this.keepHistory = config.keepHistory !== undefined ? config.keepHistory : true;
    if (!_isBoolean__default["default"](this.keepHistory)) {
      throw new Error("\"keepHistory configuration must be a boolean, ".concat(this.keepHistory, " provided."));
    }
    this.urlFilterSeparator = config.urlFilterSeparator !== undefined ? config.urlFilterSeparator : "+";
    if (!_isString__default["default"](this.urlFilterSeparator)) {
      throw new Error("\"urlFilterSeparator configuration must be a string, ".concat(this.urlFilterSeparator, " provided."));
    }
    this.urlParamValidator = config.urlParamValidator || new UrlParamValidator();
    this.urlParser = config.urlParser || new UrlParser();
    this.urlParser.urlParamsMapping = this.urlParamsMapping;

    // build the serializer from URL params to Query state by flipping the urlParamsMapping
    this.fromUrlParamsMapping = {};
    Object.keys(this.urlParamsMapping).forEach(function (stateKey) {
      _this3.fromUrlParamsMapping[_this3.urlParamsMapping[stateKey]] = stateKey;
    });
    this.get = this.get.bind(this);
    this.set = this.set.bind(this);
    this.replace = this.replace.bind(this);
  }

  /**
   * Map filters from list to string that is human readable
   * [ 'type', 'photo', [ 'subtype', 'png' ]] => type:photo+subtype:png
   */
  _createClass(UrlHandlerApi, [{
    key: "get",
    value:
    /**
     * Return a new version of the given `query` state with updated values parsed from the URL query string.
     * @param {object} queryState the `query` state
     */
    function get(queryState) {
      var urlParamsObj = this.urlParser.parse(window.location.search);
      var urlStateObj = this._mapUrlParamsToQueryState(urlParamsObj);
      var newQueryState = this._mergeParamsIntoState(urlStateObj, queryState);
      var newUrlParams = this._mapQueryStateToUrlParams(newQueryState);
      replaceHistory(newUrlParams);
      return newQueryState;
    }

    /**
     * Update the URL query string parameters from the given `query` state
     * @param {object} stateQuery the `query` state
     */
  }, {
    key: "set",
    value: function set(stateQuery) {
      if (this.keepHistory) {
        var newUrlParams = this._mapQueryStateToUrlParams(stateQuery);
        pushHistory(newUrlParams);
      } else {
        this.replace(stateQuery);
      }
    }

    /**
     * Replace the URL query string parameters from the given `query` state
     * @param {object} stateQuery the `query` state
     */
  }, {
    key: "replace",
    value: function replace(stateQuery) {
      var newUrlParams = this._mapQueryStateToUrlParams(stateQuery);
      replaceHistory(newUrlParams);
    }
  }]);
  return UrlHandlerApi;
}();

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var SET_QUERY_COMPONENT_INITIAL_STATE = "SET_QUERY_COMPONENT_INITIAL_STATE";
var SET_QUERY_STRING = "SET_QUERY_STRING";
var SET_QUERY_SORTING = "SET_QUERY_SORTING";
var SET_QUERY_SORT_BY = "SET_QUERY_SORT_BY";
var SET_QUERY_SORT_ORDER = "SET_QUERY_SORT_ORDER";
var SET_QUERY_STATE = "SET_QUERY_STATE";
var SET_QUERY_PAGINATION_PAGE = "SET_QUERY_PAGINATION_PAGE";
var SET_QUERY_PAGINATION_SIZE = "SET_QUERY_PAGINATION_SIZE";
var SET_QUERY_FILTERS = "SET_QUERY_FILTERS";
var SET_QUERY_SUGGESTIONS = "SET_QUERY_SUGGESTIONS";
var SET_SUGGESTION_STRING = "SET_SUGGESTION_STRING";
var CLEAR_QUERY_SUGGESTIONS = "CLEAR_QUERY_SUGGESTIONS";
var RESULTS_LOADING = "RESULTS_LOADING";
var RESULTS_FETCH_SUCCESS = "RESULTS_FETCH_SUCCESS";
var RESULTS_FETCH_ERROR = "RESULTS_FETCH_ERROR";
var RESULTS_UPDATE_LAYOUT = "RESULTS_UPDATE_LAYOUT";
var RESET_QUERY = "RESET_QUERY";

var onAppInitialized = function onAppInitialized(searchOnInit) {
  return function (dispatch) {
    if (searchOnInit) {
      dispatch(executeQuery({
        shouldUpdateUrlQueryString: false,
        shouldReplaceUrlQueryString: true
      }));
    }
  };
};
var updateQueryState = function updateQueryState(queryState) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_STATE,
      payload: queryState
    });
    dispatch(executeQuery());
  };
};
var updateQueryString = function updateQueryString(queryString) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_STRING,
      payload: queryString
    });
    dispatch(executeQuery());
  };
};
var updateQuerySorting = function updateQuerySorting(sortByValue, sortOrderValue) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_SORTING,
      payload: {
        sortBy: sortByValue,
        sortOrder: sortOrderValue
      }
    });
    dispatch(executeQuery());
  };
};
var updateQuerySortBy = function updateQuerySortBy(sortByValue) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_SORT_BY,
      payload: sortByValue
    });
    dispatch(executeQuery());
  };
};
var updateQuerySortOrder = function updateQuerySortOrder(sortOrderValue) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_SORT_ORDER,
      payload: sortOrderValue
    });
    dispatch(executeQuery());
  };
};
var updateQueryPaginationPage = function updateQueryPaginationPage(page) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_PAGINATION_PAGE,
      payload: page
    });
    dispatch(executeQuery());
  };
};
var updateQueryPaginationSize = function updateQueryPaginationSize(size) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_PAGINATION_SIZE,
      payload: size
    });
    dispatch(executeQuery());
  };
};
var updateQueryFilters = function updateQueryFilters(filters) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_FILTERS,
      payload: filters
    });
    dispatch(executeQuery());
  };
};
var updateResultsLayout = function updateResultsLayout(layout) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dispatch, getState, config) {
      var urlHandlerApi, newStateQuery;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              urlHandlerApi = config.urlHandlerApi;
              if (!urlHandlerApi) {
                _context.next = 8;
                break;
              }
              _context.next = 4;
              return dispatch({
                type: RESULTS_UPDATE_LAYOUT,
                payload: layout
              });
            case 4:
              newStateQuery = getState().query;
              urlHandlerApi.set(newStateQuery);
              _context.next = 9;
              break;
            case 8:
              dispatch({
                type: RESULTS_UPDATE_LAYOUT,
                payload: layout
              });
            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
};
var resetQuery = function resetQuery() {
  return function (dispatch, getState, config) {
    dispatch({
      type: RESET_QUERY,
      payload: _objectSpread2({
        queryString: "",
        page: 1,
        filters: []
      }, config.initialQueryState)
    });
    dispatch(executeQuery());
  };
};

/**
 * Update URL parameters.
 * @param {object} queryState - current query state
 * @param {object} appConfig - app config
 * @param {boolean} shouldReplaceUrlQueryString - true if should replace the last browser history state
 * @param {boolean} shouldUpdateUrlQueryString - true if it should add a new browser history state
 */
var updateURLParameters = function updateURLParameters(queryState, appConfig, shouldReplaceUrlQueryString, shouldUpdateUrlQueryString) {
  var urlHandlerApi = appConfig.urlHandlerApi;
  if (urlHandlerApi) {
    if (shouldReplaceUrlQueryString) {
      urlHandlerApi.replace(queryState);
    } else if (shouldUpdateUrlQueryString) {
      urlHandlerApi.set(queryState);
    }
  }
};

/**
 * Update query state and URL args with the new query state given by the backend response.
 * @param {object} response - API response
 * @param {func} dispatch - Redux `dispath` function
 * @param {func} getState - function to get the Redux state
 * @param {object} appConfig - app config
 */
var updateQueryStateAfterResponse = function updateQueryStateAfterResponse(response, dispatch, getState, appConfig) {
  var prevState = getState().query;
  dispatch({
    type: SET_QUERY_STATE,
    payload: _objectSpread2(_objectSpread2({}, prevState), response.newQueryState)
  });
  var updatedQueryState = _cloneDeep__default["default"](getState().query);
  var urlHandlerApi = appConfig.urlHandlerApi;
  if (urlHandlerApi) {
    // Replace the URL args with the response new query state
    urlHandlerApi.replace(updatedQueryState);
  }
  delete response.newStateQuery;
  return response;
};
var updateSearchSorting = function updateSearchSorting(queryState, appState, appConfig, dispatch) {
  function getSearchSortingOnQueryString(queryState, appState, appConfig, dispatch) {
    var isQueryStringEmpty = queryState.queryString === "";
    if (isQueryStringEmpty) {
      queryState.sortBy = appConfig.defaultSortingOnEmptyQueryString.sortBy;
      queryState.sortOrder = appConfig.defaultSortingOnEmptyQueryString.sortOrder;
    } else {
      queryState.sortBy = appState.initialSortBy;
      queryState.sortOrder = appState.initialSortOrder;
    }
    dispatch({
      type: SET_QUERY_STATE,
      payload: queryState
    });
  }
  function getSearchSorting(queryState, appState, appConfig, dispatch) {
    var userHasChangedSorting = appState.hasUserChangedSorting;
    if (!userHasChangedSorting) {
      // change sorting only if user did not change it
      getSearchSortingOnQueryString(queryState, appState, appConfig, dispatch);
    }
  }

  // when the `defaultSortingOnEmptyQueryString` config is not defined,
  // return the current query state
  var defaultSortingDefined = !_isEmpty__default["default"](appConfig.defaultSortingOnEmptyQueryString);
  if (defaultSortingDefined) {
    // when the `defaultSortingOnEmptyQueryString` config is defined,
    // evaluate if the sorting should be automatically changed
    getSearchSorting(queryState, appState, appConfig, dispatch);
  }
};

/**
 * Execute search API request with current query state and update results state with response.
 * @param {object} options - `shouldUpdateUrlQueryString` and `shouldReplaceUrlQueryString` to choose if the
 *                           browser history state should be updated with the current query state.
 */
var executeQuery = function executeQuery() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref2$shouldUpdateUrl = _ref2.shouldUpdateUrlQueryString,
    shouldUpdateUrlQueryString = _ref2$shouldUpdateUrl === void 0 ? true : _ref2$shouldUpdateUrl,
    _ref2$shouldReplaceUr = _ref2.shouldReplaceUrlQueryString,
    shouldReplaceUrlQueryString = _ref2$shouldReplaceUr === void 0 ? false : _ref2$shouldReplaceUr;
  return /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(dispatch, getState, config) {
      var appState, queryState, searchApi, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              appState = getState().app;
              queryState = _cloneDeep__default["default"](getState().query);
              updateSearchSorting(queryState, appState, config, dispatch);

              // fetch latest query state
              queryState = _cloneDeep__default["default"](getState().query);
              updateURLParameters(queryState, config, shouldReplaceUrlQueryString, shouldUpdateUrlQueryString);
              dispatch({
                type: RESULTS_LOADING
              });
              _context2.prev = 6;
              searchApi = config.searchApi;
              _context2.next = 10;
              return searchApi.search(queryState);
            case 10:
              response = _context2.sent;
              if ("newQueryState" in response) {
                response = updateQueryStateAfterResponse(_cloneDeep__default["default"](response), dispatch, getState, config);
              }
              dispatch({
                type: RESULTS_FETCH_SUCCESS,
                payload: {
                  aggregations: response.aggregations,
                  hits: response.hits,
                  total: response.total
                }
              });
              _context2.next = 24;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](6);
              if (!(_context2.t0 instanceof RequestCancelledError)) {
                _context2.next = 22;
                break;
              }
              // do nothing when the request was cancelled, another request is normally already happening
              console.debug(_context2.t0);
              return _context2.abrupt("return");
            case 22:
              console.error(_context2.t0);
              dispatch({
                type: RESULTS_FETCH_ERROR,
                payload: {
                  error: _context2.t0
                }
              });
            case 24:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[6, 15]]);
    }));
    return function (_x4, _x5, _x6) {
      return _ref3.apply(this, arguments);
    };
  }();
};
var updateSuggestions = function updateSuggestions(suggestionString) {
  return function (dispatch) {
    dispatch({
      type: SET_SUGGESTION_STRING,
      payload: suggestionString
    });
    dispatch(executeSuggestionQuery());
  };
};
var executeSuggestionQuery = function executeSuggestionQuery() {
  return /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dispatch, getState, config) {
      var queryState, suggestionApi, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              queryState = _cloneDeep__default["default"](getState().query);
              suggestionApi = config.suggestionApi;
              _context3.prev = 2;
              _context3.next = 5;
              return suggestionApi.search(queryState);
            case 5:
              response = _context3.sent;
              dispatch({
                type: SET_QUERY_SUGGESTIONS,
                payload: {
                  suggestions: response.suggestions
                }
              });
              _context3.next = 12;
              break;
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](2);
              console.error("Could not load suggestions due to: " + _context3.t0);
            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[2, 9]]);
    }));
    return function (_x7, _x8, _x9) {
      return _ref4.apply(this, arguments);
    };
  }();
};
var clearSuggestions = function clearSuggestions() {
  return function (dispatch) {
    dispatch({
      type: CLEAR_QUERY_SUGGESTIONS,
      payload: {
        suggestions: []
      }
    });
  };
};
var updateQueryStateFromUrl = function updateQueryStateFromUrl() {
  return function (dispatch, getState, config) {
    if (config.urlHandlerApi) {
      var newState = config.urlHandlerApi.get(config.initialQueryState);
      dispatch({
        type: SET_QUERY_STATE,
        payload: newState
      });
      dispatch(executeQuery({
        shouldReplaceUrlQueryString: true
      }));
    }
  };
};

var AppContext = /*#__PURE__*/React__default["default"].createContext({});

var appReducer = function appReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case SET_QUERY_SORTING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        hasUserChangedSorting: true
      });
    case SET_QUERY_SORT_BY:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        hasUserChangedSorting: true
      });
    case SET_QUERY_SORT_ORDER:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        hasUserChangedSorting: true
      });
    default:
      return state;
  }
};

var queryReducer = function queryReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case SET_QUERY_STRING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        queryString: action.payload,
        page: 1
      });
    case SET_QUERY_SORTING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        sortBy: action.payload.sortBy,
        sortOrder: action.payload.sortOrder,
        _sortUserChanged: true,
        page: 1
      });
    case SET_QUERY_SORT_BY:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        sortBy: action.payload,
        _sortUserChanged: true,
        page: 1
      });
    case SET_QUERY_SORT_ORDER:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        sortOrder: action.payload,
        _sortUserChanged: true,
        page: 1
      });
    case SET_QUERY_PAGINATION_PAGE:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        page: action.payload
      });
    case SET_QUERY_PAGINATION_SIZE:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        size: action.payload,
        page: 1
      });
    case SET_QUERY_FILTERS:
      {
        return _objectSpread2(_objectSpread2({}, state), {}, {
          page: 1,
          filters: updateQueryFilters$1(action.payload, state.filters)
        });
      }
    case SET_QUERY_SUGGESTIONS:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        suggestions: action.payload.suggestions
      });
    case CLEAR_QUERY_SUGGESTIONS:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        suggestions: action.payload.suggestions
      });
    case SET_SUGGESTION_STRING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        suggestionString: action.payload
      });
    case SET_QUERY_COMPONENT_INITIAL_STATE:
      return _objectSpread2(_objectSpread2({}, state), action.payload);
    case SET_QUERY_STATE:
      return _objectSpread2(_objectSpread2(_objectSpread2({}, state), INITIAL_QUERY_STATE), updateQueryState$1(INITIAL_QUERY_STATE, action.payload, INITIAL_QUERY_STATE_KEYS));
    case RESULTS_UPDATE_LAYOUT:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        layout: action.payload
      });
    case RESET_QUERY:
      return _objectSpread2(_objectSpread2({}, state), action.payload);
    default:
      return state;
  }
};

var resultsReducer = function resultsReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case RESULTS_LOADING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        loading: true,
        data: _objectSpread2({}, state.data)
      });
    case RESULTS_FETCH_SUCCESS:
      return {
        loading: false,
        data: _objectSpread2(_objectSpread2({}, state.data), {}, {
          aggregations: action.payload.aggregations,
          hits: action.payload.hits,
          total: action.payload.total
        }),
        error: {}
      };
    case RESULTS_FETCH_ERROR:
      return {
        loading: false,
        data: _objectSpread2(_objectSpread2({}, state.data), {}, {
          aggregations: {},
          hits: [],
          total: 0
        }),
        error: action.payload.error
      };
    default:
      return state;
  }
};

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var rootReducer = redux.combineReducers({
  app: appReducer,
  query: queryReducer,
  results: resultsReducer
});

function isSortingDifferent(_ref, _ref2) {
  var sortBy1 = _ref.sortBy,
    sortOrder1 = _ref.sortOrder;
  var sortBy2 = _ref2.sortBy,
    sortOrder2 = _ref2.sortOrder;
  var differentSortBy = sortBy1 !== sortBy2;
  var differentSortOrder = sortOrder1 !== sortOrder2;
  return differentSortBy || differentSortOrder;
}
function urlParamsChangedSorting(appConfig, initialQueryState, queryStateFromURLParams) {
  // check if the sorting has been changed by the URL params
  // it is not the initial or defaultOnEmpty values
  var differInitialSorting = isSortingDifferent(queryStateFromURLParams, initialQueryState);
  var isDefaultOnEmptyDefined = !_isEmpty__default["default"](appConfig.defaultSortingOnEmptyQueryString);
  var differDefaultOnEmtpy = false;
  if (isDefaultOnEmptyDefined) {
    differDefaultOnEmtpy = isSortingDifferent(queryStateFromURLParams, appConfig.defaultSortingOnEmptyQueryString);
  }
  var isDifferentThanInitialAndDefaultOnEmpty = differInitialSorting && differDefaultOnEmtpy;
  return isDifferentThanInitialAndDefaultOnEmpty;
}
function getInitialState(appConfig) {
  // update `query` state
  var initialQueryState = _objectSpread2(_objectSpread2({}, INITIAL_QUERY_STATE), appConfig.initialQueryState);

  // update initial state depending on URL params values
  var queryStateFromURLParams = appConfig.urlHandlerApi ? appConfig.urlHandlerApi.get(initialQueryState) : initialQueryState;

  // the sorting value in URL params takes precedence
  // evaluate if URL params have sorting with a specific value
  // that is not initial or defaultOnEmpty
  var hasUserChangedSorting = urlParamsChangedSorting(appConfig, initialQueryState, queryStateFromURLParams);

  // update `app` state
  var initialAppState = _objectSpread2(_objectSpread2({}, INITIAL_APP_STATE), {}, {
    hasUserChangedSorting: hasUserChangedSorting,
    initialSortBy: initialQueryState.sortBy,
    initialSortOrder: initialQueryState.sortOrder
  });

  // update `results` state
  var initialResultsState = _objectSpread2(_objectSpread2({}, INITIAL_RESULTS_STATE), {}, {
    loading: appConfig.searchOnInit
  });
  return {
    app: initialAppState,
    query: queryStateFromURLParams,
    results: initialResultsState
  };
}
function createStoreWithConfig(appConfig) {
  var preloadedState = getInitialState(appConfig);
  return redux.createStore(rootReducer, preloadedState, redux.applyMiddleware(thunk__default["default"].withExtraArgument(appConfig)));
}

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

/**
 * Build namespaced unique identifier.
 * @param {string} elementName component element name
 * @param {string} overridableId unique identifier passed as prop to overridable component
 * @param {string} appName the app name
 * @return {string} the unique id string with the format 'appName.elementName.overridableId'
 */
function buildUID(elementName) {
  var overridableId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var appName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var _overridableId = overridableId ? ".".concat(overridableId) : "";
  var _appName = appName ? "".concat(appName, ".") : "";
  return "".concat(_appName).concat(elementName).concat(_overridableId);
}

var Bootstrap$1 = /*#__PURE__*/function (_Component) {
  _inherits(Bootstrap, _Component);
  var _super = _createSuper(Bootstrap);
  function Bootstrap(props) {
    var _this;
    _classCallCheck(this, Bootstrap);
    _this = _super.call(this, props);
    _this.updateQueryState = function (query) {
      var updateQueryState = _this.props.updateQueryState;
      updateQueryState(query);
    };
    _this.onQueryChanged = function (_ref) {
      var payload = _ref.detail;
      var appName = _this.context.appName;
      var appNameNotDefined = !appName;
      if (appNameNotDefined) {
        _this.updateQueryState(payload.searchQuery);
      } else {
        var eventRecipient = payload.appName;
        var sameName = eventRecipient === appName;
        if (sameName) {
          _this.updateQueryState(payload.searchQuery);
        } else {
          console.debug("React-SearchKit '".concat(appName, "': ignoring event sent for app '").concat(eventRecipient, "'"));
        }
      }
    };
    _this.searchOnInit = props.searchOnInit;
    _this.eventListenerEnabled = props.eventListenerEnabled;
    _this.onAppInitialized = props.onAppInitialized;
    _this.searchOnUrlQueryStringChanged = props.searchOnUrlQueryStringChanged;
    return _this;
  }
  _createClass(Bootstrap, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (this.eventListenerEnabled) {
        window.addEventListener("queryChanged", this.onQueryChanged);
      }
      window.onpopstate = function () {
        _this2.searchOnUrlQueryStringChanged();
      };
      this.onAppInitialized(this.searchOnInit);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.onpopstate = function () {};
      window.removeEventListener("queryChanged", this.onQueryChanged);
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children;
    }
  }]);
  return Bootstrap;
}(React.Component);
Bootstrap$1.defaultProps = {
  searchOnInit: true,
  eventListenerEnabled: false
};
Bootstrap$1.contextType = AppContext;
var BootstrapComponent = Overridable__default["default"].component("Bootstrap", Bootstrap$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$c = function mapDispatchToProps(dispatch) {
  return {
    onAppInitialized: function onAppInitialized$1(searchOnInit) {
      return dispatch(onAppInitialized(searchOnInit));
    },
    updateQueryState: function updateQueryState$1(queryState) {
      return dispatch(updateQueryState(queryState));
    },
    searchOnUrlQueryStringChanged: function searchOnUrlQueryStringChanged() {
      return dispatch(updateQueryStateFromUrl());
    }
  };
};
var Bootstrap = reactRedux.connect(null, mapDispatchToProps$c)(BootstrapComponent);

var ReactSearchKit = /*#__PURE__*/function (_Component) {
  _inherits(ReactSearchKit, _Component);
  var _super = _createSuper(ReactSearchKit);
  function ReactSearchKit(props) {
    var _this;
    _classCallCheck(this, ReactSearchKit);
    _this = _super.call(this, props);
    var appConfig = {
      searchApi: props.searchApi,
      suggestionApi: props.suggestionApi,
      urlHandlerApi: props.urlHandlerApi.enabled ? props.urlHandlerApi.customHandler || new UrlHandlerApi(props.urlHandlerApi.overrideConfig) : null,
      searchOnInit: props.searchOnInit,
      initialQueryState: props.initialQueryState,
      defaultSortingOnEmptyQueryString: props.defaultSortingOnEmptyQueryString
    };
    _this.store = createStoreWithConfig(appConfig);
    _this.appName = props.appName;
    _this.eventListenerEnabled = props.eventListenerEnabled;
    return _this;
  }
  _createClass(ReactSearchKit, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        appName = _this$props.appName,
        children = _this$props.children,
        eventListenerEnabled = _this$props.eventListenerEnabled,
        overridableId = _this$props.overridableId,
        searchOnInit = _this$props.searchOnInit;
      var context = {
        appName: appName,
        buildUID: function buildUID$1(element, overrideId) {
          return buildUID(element, overrideId, appName);
        }
      };
      var _overridableId = buildUID("ReactSearchKit.children", overridableId, appName);
      return /*#__PURE__*/React__default["default"].createElement(AppContext.Provider, {
        value: context
      }, /*#__PURE__*/React__default["default"].createElement(reactRedux.Provider, {
        store: this.store
      }, /*#__PURE__*/React__default["default"].createElement(Bootstrap, {
        searchOnInit: searchOnInit,
        eventListenerEnabled: eventListenerEnabled
      }, /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
        id: _overridableId
      }, children))));
    }
  }]);
  return ReactSearchKit;
}(React.Component);
ReactSearchKit.defaultProps = {
  suggestionApi: null,
  urlHandlerApi: {
    enabled: true,
    overrideConfig: {},
    customHandler: null
  },
  searchOnInit: true,
  appName: "",
  eventListenerEnabled: false,
  overridableId: "",
  initialQueryState: {},
  defaultSortingOnEmptyQueryString: {}
};
ReactSearchKit.contextType = AppContext;
var ReactSearchKit$1 = Overridable__default["default"].component("ReactSearchKit", ReactSearchKit);

var ActiveFilters$1 = /*#__PURE__*/function (_Component) {
  _inherits(ActiveFilters, _Component);
  var _super = _createSuper(ActiveFilters);
  function ActiveFilters(props) {
    var _this;
    _classCallCheck(this, ActiveFilters);
    _this = _super.call(this, props);
    _this._getLabel = function (filter) {
      var aggName = filter[0];
      var value = filter[1];
      var currentFilter = [aggName, value];
      var hasChild = filter.length === 3;
      if (hasChild) {
        var _this$_getLabel = _this._getLabel(filter[2]),
          label = _this$_getLabel.label,
          activeFilter = _this$_getLabel.activeFilter;
        value = "".concat(value, ".").concat(label);
        currentFilter.push(activeFilter);
      }
      return {
        label: value,
        activeFilter: currentFilter
      };
    };
    _this.updateQueryFilters = props.updateQueryFilters;
    return _this;
  }
  _createClass(ActiveFilters, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        filters = _this$props.filters,
        overridableId = _this$props.overridableId;
      return !!filters.length && /*#__PURE__*/React__default["default"].createElement(Element$g, {
        filters: filters,
        removeActiveFilter: this.updateQueryFilters,
        getLabel: this._getLabel,
        overridableId: overridableId
      });
    }
  }]);
  return ActiveFilters;
}(React.Component);
ActiveFilters$1.defaultProps = {
  overridableId: ""
};
var Element$g = function Element(_ref) {
  var overridableId = _ref.overridableId,
    filters = _ref.filters,
    removeActiveFilter = _ref.removeActiveFilter,
    getLabel = _ref.getLabel;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ActiveFilters.element", overridableId),
    filters: filters,
    removeActiveFilter: removeActiveFilter,
    getLabel: getLabel
  }, /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, filters.map(function (filter, index) {
    var _getLabel = getLabel(filter),
      label = _getLabel.label,
      activeFilter = _getLabel.activeFilter;
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react/no-array-index-key
      React__default["default"].createElement(semanticUiReact.Label, {
        image: true,
        key: index,
        onClick: function onClick() {
          return removeActiveFilter(activeFilter);
        }
      }, label, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Icon, {
        name: "delete"
      }))
    );
  })));
};
Element$g.defaultProps = {
  overridableId: ""
};
var ActiveFiltersComponent = Overridable__default["default"].component("ActiveFilters", ActiveFilters$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$b = function mapDispatchToProps(dispatch) {
  return {
    updateQueryFilters: function updateQueryFilters$1(filter) {
      return dispatch(updateQueryFilters(filter));
    }
  };
};
var ActiveFilters = reactRedux.connect(function (state) {
  return {
    filters: state.query.filters
  };
}, mapDispatchToProps$b)(ActiveFiltersComponent);

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".AutoCompleteText{position:relative;z-index:100}.AutoCompleteText .input button,.AutoCompleteText .input input{border:none;border-radius:0}.AutoCompleteText ul{background-color:#fff;border:1px solid #e0e1e2;border-radius:0 0 .3rem .3rem;color:#000;list-style-type:none;margin:0;padding:0;position:absolute;text-align:left;width:100%}.AutoCompleteText ul:before{content:\"\"}.AutoCompleteText li{cursor:pointer;padding:.3em 1em}.AutoCompleteText li:hover{background-color:#e0e1e2;border-radius:.3rem;text-decoration:underline}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vaG9tZS9ydW5uZXIvd29yay9yZWFjdC1zZWFyY2hraXQvcmVhY3Qtc2VhcmNoa2l0L3NyYy9saWIvY29tcG9uZW50cy9BdXRvY29tcGxldGVTZWFyY2hCYXIvQXV0b2NvbXBsZXRlU2VhcmNoQmFyLnNjc3MiLCJBdXRvY29tcGxldGVTZWFyY2hCYXIuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFDRSxpQkFBQSxDQUNBLFdDQ0YsQ0RPQSwrREFDRSxXQUFBLENBQ0EsZUNDRixDREVBLHFCQU1FLHFCQUFBLENBR0Esd0JBQUEsQ0FDQSw2QkFBQSxDQUxBLFVBQUEsQ0FGQSxvQkFBQSxDQUlBLFFBQUEsQ0FDQSxTQUFBLENBTkEsaUJBQUEsQ0FFQSxlQUFBLENBSEEsVUNVRixDREVBLDRCQUNFLFVDQ0YsQ0RFQSxxQkFFRSxjQUFBLENBREEsZ0JDRUYsQ0RFQSwyQkFFRSx3QkFBQSxDQUNBLG1CQUFBLENBRkEseUJDR0YiLCJmaWxlIjoiQXV0b2NvbXBsZXRlU2VhcmNoQmFyLnNjc3MifQ== */";
styleInject(css_248z);

var _this2 = undefined;
var _excluded$3 = ["overridableId", "placeholder", "queryString", "querySuggestions", "onInputChange", "executeSearch"],
  _excluded2 = ["overridableId"];
var AutocompleteSearchBar$1 = /*#__PURE__*/function (_Component) {
  _inherits(AutocompleteSearchBar, _Component);
  var _super = _createSuper(AutocompleteSearchBar);
  function AutocompleteSearchBar(props) {
    var _this;
    _classCallCheck(this, AutocompleteSearchBar);
    _this = _super.call(this, props);
    _this._handleAutocompleteChange = function (suggestionString) {
      if (suggestionString.length >= _this.minCharsToAutocomplete) {
        _this.updateSuggestions(suggestionString);
      }
    };
    _this.onInputChange = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(queryString) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.setState({
                  currentValue: queryString
                });
              case 2:
                _this.handleAutocompleteChange(_this.state.currentValue);
              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    _this.executeSearch = function () {
      _this.updateQueryString(_this.state.currentValue);
    };
    _this.updateQueryString = _this.props.updateQueryString;
    _this.updateSuggestions = _this.props.debounce ? ___default["default"].debounce(_this.props.updateSuggestions, _this.props.debounceTime, {
      leading: true
    }) : _this.props.updateSuggestions;
    _this.clearSuggestions = _this.props.clearSuggestions;
    _this.minCharsToAutocomplete = _this.props.minCharsToAutocomplete;
    _this.state = {
      currentValue: _this.props.queryString || ""
    };
    _this.handleAutocompleteChange = props.handleAutocompleteChange || _this._handleAutocompleteChange;
    return _this;
  }
  _createClass(AutocompleteSearchBar, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        placeholder = _this$props.placeholder,
        suggestions = _this$props.suggestions,
        overridableId = _this$props.overridableId;
      return /*#__PURE__*/React__default["default"].createElement(Element$f, {
        placeholder: placeholder,
        queryString: this.state.currentValue,
        querySuggestions: suggestions,
        onInputChange: this.onInputChange,
        executeSearch: this.executeSearch,
        overridableId: overridableId
      });
    }
  }]);
  return AutocompleteSearchBar;
}(React.Component);
AutocompleteSearchBar$1.defaultProps = {
  handleAutocompleteChange: null,
  placeholder: "Type something",
  minCharsToAutocomplete: 3,
  overridableId: ""
};
var AutocompleteSearchBarUncontrolled = function AutocompleteSearchBarUncontrolled(props) {
  return /*#__PURE__*/React__default["default"].createElement(AutocompleteSearchBar$1, Object.assign({
    key: props.queryString
  }, props));
};
var Element$f = function Element(_ref2) {
  var overridableId = _ref2.overridableId,
    placeholder = _ref2.placeholder,
    queryString = _ref2.queryString,
    querySuggestions = _ref2.querySuggestions,
    onInputChange = _ref2.onInputChange,
    executeSearch = _ref2.executeSearch,
    props = _objectWithoutProperties(_ref2, _excluded$3);
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var onBtnSearchClick = function onBtnSearchClick(event, input) {
    executeSearch();
  };
  var onKeyPress = function onKeyPress(event, input) {
    if (event.key === "Enter") {
      executeSearch();
    }
  };
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], Object.assign({
    id: buildUID("AutocompleteSearchBar.element", overridableId)
  }, props), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "AutoCompleteText"
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Input, {
    action: {
      content: "Search",
      onClick: onBtnSearchClick
    },
    fluid: true,
    placeholder: placeholder,
    onChange: function onChange(event, _ref3) {
      var value = _ref3.value;
      onInputChange(value);
    },
    value: queryString,
    onKeyPress: onKeyPress
  }), /*#__PURE__*/React__default["default"].createElement(Suggestions, {
    querySuggestions: querySuggestions,
    overridableId: overridableId
  })));
};
var Suggestions = function Suggestions(_ref4) {
  var overridableId = _ref4.overridableId,
    props = _objectWithoutProperties(_ref4, _excluded2);
  var querySuggestions = props.querySuggestions;
  var _useContext2 = React.useContext(AppContext),
    buildUID = _useContext2.buildUID;
  var onSuggestionSelected = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(suggestion) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this2.setState({
                currentValue: suggestion
              });
            case 2:
              _this2.clearSuggestions();
              _this2.executeSearch();
            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return function onSuggestionSelected(_x2) {
      return _ref5.apply(this, arguments);
    };
  }();
  if (querySuggestions.length === 0) {
    return null;
  }
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], Object.assign({
    id: buildUID("AutocompleteSearchBar.suggestions", overridableId)
  }, props), /*#__PURE__*/React__default["default"].createElement("ul", null, querySuggestions.map(function (text) {
    return /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Button, {
      as: "li",
      onClick: function onClick() {
        return onSuggestionSelected(text);
      },
      key: text
    }, text);
  })));
};
var AutocompleteSearchBarComponent = Overridable__default["default"].component("AutocompleteSearchBar", AutocompleteSearchBarUncontrolled);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$a = function mapDispatchToProps(dispatch) {
  return {
    updateQueryString: function updateQueryString$1(query) {
      return dispatch(updateQueryString(query));
    },
    updateSuggestions: function updateSuggestions$1(query) {
      return dispatch(updateSuggestions(query));
    },
    clearSuggestions: function clearSuggestions$1() {
      return dispatch(clearSuggestions());
    }
  };
};
var mapStateToProps = function mapStateToProps(state) {
  return {
    queryString: state.query.queryString,
    suggestions: state.query.suggestions
  };
};
var AutocompleteSearchBar = reactRedux.connect(mapStateToProps, mapDispatchToProps$a)(AutocompleteSearchBarComponent);

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var BucketAggregationValues = /*#__PURE__*/function (_Component) {
  _inherits(BucketAggregationValues, _Component);
  var _super = _createSuper(BucketAggregationValues);
  function BucketAggregationValues(props) {
    var _this;
    _classCallCheck(this, BucketAggregationValues);
    _this = _super.call(this, props);
    _this._isSelected = function (aggName, value, selectedFilters) {
      // return True there is at least one filter that has this value
      return selectedFilters.filter(function (filter) {
        return filter[0] === aggName && filter[1] === value;
      }).length >= 1;
    };
    _this.getChildAggCmps = function (bucket, selectedFilters) {
      var hasChildAggregation = _this.childAgg && _this.childAgg["aggName"] in bucket;
      var selectedChildFilters = [];
      if (hasChildAggregation) {
        var childBuckets = bucket[_this.childAgg["aggName"]]["buckets"];
        selectedFilters.forEach(function (filter) {
          var isThisAggregation = filter[0] === _this.aggName;
          var isThisValue = filter[1] === bucket.key;
          var hasChild = filter.length === 3;
          if (isThisAggregation && isThisValue && hasChild) {
            selectedChildFilters.push(filter[2]);
          }
        });
        var onFilterClicked = function onFilterClicked(value) {
          _this.onFilterClicked([_this.aggName, bucket.key, value]);
        };
        return /*#__PURE__*/React__default["default"].createElement(BucketAggregationValues, {
          buckets: childBuckets,
          selectedFilters: selectedChildFilters,
          field: _this.childAgg.field,
          aggName: _this.childAgg.aggName,
          childAgg: _this.childAgg.childAgg,
          onFilterClicked: onFilterClicked
        });
      }
      return null;
    };
    _this.field = props.field;
    _this.aggName = props.aggName;
    _this.childAgg = props.childAgg;
    _this.onFilterClicked = props.onFilterClicked;
    return _this;
  }
  _createClass(BucketAggregationValues, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props,
        buckets = _this$props.buckets,
        selectedFilters = _this$props.selectedFilters,
        overridableId = _this$props.overridableId;
      var valuesCmp = buckets.map(function (bucket) {
        var keyField = bucket.key_as_string ? bucket.key_as_string : bucket.key;
        var isSelected = _this2._isSelected(_this2.aggName, keyField, selectedFilters);
        var onFilterClicked = function onFilterClicked(value) {
          _this2.onFilterClicked([_this2.aggName, value]);
        };
        var getChildAggCmps = function getChildAggCmps(bucket) {
          return _this2.getChildAggCmps(bucket, selectedFilters);
        };
        return /*#__PURE__*/React__default["default"].createElement(ValueElement, {
          key: bucket.key,
          bucket: bucket,
          keyField: keyField,
          isSelected: isSelected,
          onFilterClicked: onFilterClicked,
          getChildAggCmps: getChildAggCmps,
          overridableId: overridableId
        });
      });
      return /*#__PURE__*/React__default["default"].createElement(ContainerElement, {
        valuesCmp: valuesCmp,
        overridableId: overridableId
      });
    }
  }]);
  return BucketAggregationValues;
}(React.Component);
BucketAggregationValues.defaultProps = {
  childAgg: null,
  overridableId: ""
};
var ContainerElement = function ContainerElement(_ref) {
  var valuesCmp = _ref.valuesCmp,
    overridableId = _ref.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("BucketAggregationContainer.element", overridableId),
    valuesCmp: valuesCmp
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.List, null, valuesCmp));
};
ContainerElement.defaultProps = {
  overridableId: ""
};
var ValueElement = function ValueElement(_ref2) {
  var bucket = _ref2.bucket,
    isSelected = _ref2.isSelected,
    onFilterClicked = _ref2.onFilterClicked,
    getChildAggCmps = _ref2.getChildAggCmps,
    overridableId = _ref2.overridableId,
    keyField = _ref2.keyField;
  var _useContext2 = React.useContext(AppContext),
    buildUID = _useContext2.buildUID;
  var label = bucket.label ? bucket.label : "".concat(keyField, " (").concat(bucket.doc_count.toLocaleString("en-US"), ")");
  var childAggCmps = getChildAggCmps(bucket);
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("BucketAggregationValues.element", overridableId),
    bucket: bucket,
    label: label,
    onFilterClicked: onFilterClicked,
    isSelected: isSelected,
    childAggCmps: childAggCmps
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.List.Item, {
    key: bucket.key
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Checkbox, {
    label: label,
    value: bucket.key,
    onClick: function onClick() {
      return onFilterClicked(bucket.key);
    },
    checked: isSelected
  }), childAggCmps));
};
ValueElement.defaultProps = {
  overridableId: ""
};
var BucketAggregationValues$1 = Overridable__default["default"].component("BucketAggregationValues", BucketAggregationValues);

var _excluded$2 = ["userSelectionFilters", "resultsAggregations", "overridableId"];
var BucketAggregation$1 = /*#__PURE__*/function (_Component) {
  _inherits(BucketAggregation, _Component);
  var _super = _createSuper(BucketAggregation);
  function BucketAggregation(props) {
    var _this;
    _classCallCheck(this, BucketAggregation);
    _this = _super.call(this, props);
    _this.onFilterClicked = function (filter) {
      _this.updateQueryFilters(filter);
    };
    _this._renderValues = function (resultBuckets, selectedFilters) {
      var overridableId = _this.props.overridableId;
      return /*#__PURE__*/React__default["default"].createElement(BucketAggregationValues$1, {
        buckets: resultBuckets,
        selectedFilters: selectedFilters,
        field: _this.agg.field,
        aggName: _this.agg.aggName,
        childAgg: _this.agg.childAgg,
        onFilterClicked: _this.onFilterClicked,
        overridableId: overridableId
      });
    };
    _this._getSelectedFilters = function (userSelectionFilters) {
      // get selected filters for this field only
      return userSelectionFilters.filter(function (filter) {
        return filter[0] === _this.agg.aggName;
      });
    };
    _this._getResultBuckets = function (resultsAggregations) {
      // get buckets of this field
      var thisAggs = _get__default["default"](resultsAggregations, _this.agg.aggName, {});
      if ("buckets" in thisAggs) {
        if (!Array.isArray(thisAggs["buckets"])) {
          // buckets can be objects or arrays: convert to array if object
          // to keep it consistent
          thisAggs["buckets"] = Object.entries(thisAggs["buckets"]).map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];
            return _objectSpread2(_objectSpread2({}, value), {}, {
              key: key
            });
          });
        }
        return thisAggs["buckets"];
      }
      return [];
    };
    _this.title = props.title;
    _this.agg = props.agg;
    _this.updateQueryFilters = props.updateQueryFilters;
    return _this;
  }
  _createClass(BucketAggregation, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        userSelectionFilters = _this$props.userSelectionFilters,
        resultsAggregations = _this$props.resultsAggregations,
        overridableId = _this$props.overridableId,
        props = _objectWithoutProperties(_this$props, _excluded$2);
      var selectedFilters = this._getSelectedFilters(userSelectionFilters);
      var resultBuckets = this._getResultBuckets(resultsAggregations);
      var valuesCmp = resultBuckets.length ? this._renderValues(resultBuckets, selectedFilters) : null;
      return /*#__PURE__*/React__default["default"].createElement(Element$e, Object.assign({
        title: this.title,
        containerCmp: valuesCmp,
        overridableId: overridableId
      }, props));
    }
  }]);
  return BucketAggregation;
}(React.Component);
BucketAggregation$1.defaultProps = {
  overridableId: ""
};
var Element$e = function Element(_ref3) {
  var overridableId = _ref3.overridableId,
    agg = _ref3.agg,
    title = _ref3.title,
    containerCmp = _ref3.containerCmp,
    updateQueryFilters = _ref3.updateQueryFilters;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return containerCmp && /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("BucketAggregation.element", overridableId),
    agg: agg,
    title: title,
    containerCmp: containerCmp,
    updateQueryFilters: updateQueryFilters
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Content, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Header, null, title)), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Content, null, containerCmp)));
};
Element$e.defaultProps = {
  containerCmp: null,
  overridableId: ""
};
var BucketAggregationComponent = Overridable__default["default"].component("BucketAggregation", BucketAggregation$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$9 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryFilters: function updateQueryFilters$1(filter) {
      return dispatch(updateQueryFilters(filter));
    }
  };
};
var BucketAggregation = reactRedux.connect(function (state) {
  return {
    userSelectionFilters: state.query.filters,
    resultsAggregations: state.results.data.aggregations
  };
}, mapDispatchToProps$9)(BucketAggregationComponent);

var ShouldRender = /*#__PURE__*/function (_Component) {
  _inherits(ShouldRender, _Component);
  var _super = _createSuper(ShouldRender);
  function ShouldRender() {
    _classCallCheck(this, ShouldRender);
    return _super.apply(this, arguments);
  }
  _createClass(ShouldRender, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        children = _this$props.children,
        condition = _this$props.condition;
      return condition ? children : null;
    }
  }]);
  return ShouldRender;
}(React.Component);
ShouldRender.defaultProps = {
  condition: true
};
var ShouldRender$1 = Overridable__default["default"].component("ShouldRender", ShouldRender);

var Count$1 = /*#__PURE__*/function (_Component) {
  _inherits(Count, _Component);
  var _super = _createSuper(Count);
  function Count() {
    _classCallCheck(this, Count);
    return _super.apply(this, arguments);
  }
  _createClass(Count, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        loading = _this$props.loading,
        totalResults = _this$props.totalResults,
        label = _this$props.label,
        overridableId = _this$props.overridableId;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: !loading && totalResults > 0
      }, label( /*#__PURE__*/React__default["default"].createElement(Element$d, {
        totalResults: totalResults,
        overridableId: overridableId
      })));
    }
  }]);
  return Count;
}(React.Component);
Count$1.defaultProps = {
  label: function label(cmp) {
    return cmp;
  },
  overridableId: ""
};
var Element$d = function Element(_ref) {
  var totalResults = _ref.totalResults,
    overridableId = _ref.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var _overridableId = buildUID("Count.element", overridableId);
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: _overridableId,
    totalResults: totalResults
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Label, {
    color: "blue"
  }, totalResults.toLocaleString("en-US")));
};
Element$d.defaultProps = {
  overridableId: ""
};
var CountComponent = Overridable__default["default"].component("Count", Count$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var Count = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total
  };
})(CountComponent);

var _excluded$1 = ["loading", "totalResults", "error", "queryString", "extraContent", "overridableId", "userSelectionFilters"];
var EmptyResults$1 = /*#__PURE__*/function (_Component) {
  _inherits(EmptyResults, _Component);
  var _super = _createSuper(EmptyResults);
  function EmptyResults(props) {
    var _this;
    _classCallCheck(this, EmptyResults);
    _this = _super.call(this, props);
    _this.resetQuery = props.resetQuery;
    return _this;
  }
  _createClass(EmptyResults, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        loading = _this$props.loading,
        totalResults = _this$props.totalResults,
        error = _this$props.error,
        queryString = _this$props.queryString,
        extraContent = _this$props.extraContent,
        overridableId = _this$props.overridableId,
        userSelectionFilters = _this$props.userSelectionFilters,
        props = _objectWithoutProperties(_this$props, _excluded$1);
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: !loading && _isEmpty__default["default"](error) && totalResults === 0
      }, /*#__PURE__*/React__default["default"].createElement(Element$c, Object.assign({}, props, {
        queryString: queryString,
        resetQuery: this.resetQuery,
        extraContent: extraContent,
        userSelectionFilters: userSelectionFilters,
        overridableId: overridableId
      })));
    }
  }]);
  return EmptyResults;
}(React.Component);
EmptyResults$1.defaultProps = {
  queryString: "",
  extraContent: null,
  overridableId: ""
};
var Element$c = function Element(_ref) {
  var overridableId = _ref.overridableId,
    queryString = _ref.queryString,
    resetQuery = _ref.resetQuery,
    extraContent = _ref.extraContent,
    userSelectionFilters = _ref.userSelectionFilters;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("EmptyResults.element", overridableId),
    queryString: queryString,
    resetQuery: resetQuery,
    extraContent: extraContent,
    userSelectionFilters: userSelectionFilters
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Segment, {
    placeholder: true,
    textAlign: "center"
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Header, {
    icon: true
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Icon, {
    name: "search"
  }), "No results found!"), queryString && /*#__PURE__*/React__default["default"].createElement("em", null, "Current search \"", queryString, "\""), /*#__PURE__*/React__default["default"].createElement("br", null), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Button, {
    primary: true,
    onClick: function onClick() {
      return resetQuery();
    }
  }, "Clear query"), extraContent));
};
Element$c.defaultProps = {
  queryString: "",
  extraContent: null,
  overridableId: ""
};
var EmptyResultsComponent = Overridable__default["default"].component("EmptyResults", EmptyResults$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$8 = function mapDispatchToProps(dispatch) {
  return {
    resetQuery: function resetQuery$1() {
      return dispatch(resetQuery());
    }
  };
};
var EmptyResults = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    error: state.results.error,
    queryString: state.query.queryString,
    userSelectionFilters: state.query.filters
  };
}, mapDispatchToProps$8)(EmptyResultsComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2022 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function Error$2(_ref) {
  var loading = _ref.loading,
    error = _ref.error,
    overridableId = _ref.overridableId;
  return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
    condition: !loading && !_isEmpty__default["default"](error)
  }, /*#__PURE__*/React__default["default"].createElement(Element$b, {
    error: error,
    overridableId: overridableId
  }));
}
Error$2.defaultProps = {
  overridableId: ""
};
var Element$b = function Element(_ref2) {
  var error = _ref2.error,
    overridableId = _ref2.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("Error.element", overridableId),
    error: error
  }, /*#__PURE__*/React__default["default"].createElement("div", null, "Oops! Something went wrong while fetching results."));
};
Element$b.defaultProps = {
  overridableId: ""
};
var ErrorComponent = Overridable__default["default"].component("Error", Error$2);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var Error$1 = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    error: state.results.error
  };
})(ErrorComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function withState(Component) {
  var WrappedComponent = function WrappedComponent(props) {
    return /*#__PURE__*/React__default["default"].createElement(Component, props);
  };
  var mapStateToProps = function mapStateToProps(state) {
    return {
      currentQueryState: state.query,
      currentResultsState: state.results
    };
  };
  var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
      updateQueryState: function updateQueryState$1(queryState) {
        return dispatch(updateQueryState(queryState));
      }
    };
  };
  return reactRedux.connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);
}

var LayoutSwitcher$1 = /*#__PURE__*/function (_Component) {
  _inherits(LayoutSwitcher, _Component);
  var _super = _createSuper(LayoutSwitcher);
  function LayoutSwitcher(props) {
    var _this;
    _classCallCheck(this, LayoutSwitcher);
    _this = _super.call(this, props);
    _this.onLayoutChange = function (layoutName) {
      _this.updateLayout(layoutName);
    };
    _this.updateLayout = props.updateLayout;
    return _this;
  }
  _createClass(LayoutSwitcher, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        currentLayout = _this$props.currentLayout,
        loading = _this$props.loading,
        totalResults = _this$props.totalResults,
        overridableId = _this$props.overridableId;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: currentLayout !== null && !loading && totalResults > 0
      }, /*#__PURE__*/React__default["default"].createElement(Element$a, {
        currentLayout: currentLayout,
        onLayoutChange: this.onLayoutChange,
        overridableId: overridableId
      }));
    }
  }]);
  return LayoutSwitcher;
}(React.Component);
LayoutSwitcher$1.defaultProps = {
  currentLayout: null,
  overridableId: ""
};
var Element$a = function Element(_ref) {
  var overridableId = _ref.overridableId,
    currentLayout = _ref.currentLayout,
    onLayoutChange = _ref.onLayoutChange;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("LayoutSwitcher.element", overridableId),
    currentLayout: currentLayout,
    onLayoutChange: onLayoutChange
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Menu, {
    compact: true,
    icon: true
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Menu.Item, {
    name: "list",
    active: currentLayout === "list",
    onClick: function onClick(_, _ref2) {
      var name = _ref2.name;
      return onLayoutChange(name);
    }
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Icon, {
    name: "list layout"
  })), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Menu.Item, {
    name: "grid",
    active: currentLayout === "grid",
    onClick: function onClick(_, _ref3) {
      var name = _ref3.name;
      return onLayoutChange(name);
    }
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Icon, {
    name: "grid layout"
  }))));
};
Element$a.defaultProps = {
  currentLayout: null,
  overridableId: ""
};
var LayoutSwitcherComponent = Overridable__default["default"].component("LayoutSwitcher", LayoutSwitcher$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$7 = function mapDispatchToProps(dispatch) {
  return {
    updateLayout: function updateLayout(layout) {
      return dispatch(updateResultsLayout(layout));
    }
  };
};
var LayoutSwitcher = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    currentLayout: state.query.layout,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$7)(LayoutSwitcherComponent);

var _excluded = ["overridableId", "currentPage", "currentSize", "totalResults", "onPageChange", "options", "maxTotalResults"];
var defaultOptions = {
  boundaryRangeCount: 1,
  siblingRangeCount: 1,
  showEllipsis: true,
  showFirst: true,
  showLast: true,
  showPrev: true,
  showNext: true,
  size: "large"
};
var Pagination$1 = /*#__PURE__*/function (_Component) {
  _inherits(Pagination, _Component);
  var _super = _createSuper(Pagination);
  function Pagination(props) {
    var _this;
    _classCallCheck(this, Pagination);
    _this = _super.call(this, props);
    _this.onPageChange = function (activePage) {
      var currentPage = _this.props.currentPage;
      if (activePage === currentPage) return;
      _this.updateQueryPage(activePage);
    };
    _this.updateQueryPage = props.updateQueryPage;
    _this.options = props.options ? _objectSpread2(_objectSpread2({}, defaultOptions), props.options) : defaultOptions;
    return _this;
  }
  _createClass(Pagination, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        loading = _this$props.loading,
        totalResults = _this$props.totalResults,
        currentPage = _this$props.currentPage,
        currentSize = _this$props.currentSize,
        overridableId = _this$props.overridableId;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: !loading && currentPage > -1 && currentSize > -1 && totalResults > 0
      }, /*#__PURE__*/React__default["default"].createElement(Element$9, {
        currentPage: currentPage,
        currentSize: currentSize,
        totalResults: totalResults,
        onPageChange: this.onPageChange,
        options: this.options,
        overridableId: overridableId
      }));
    }
  }]);
  return Pagination;
}(React.Component);
Pagination$1.defaultProps = {
  options: {},
  overridableId: ""
};
var Element$9 = function Element(_ref) {
  var overridableId = _ref.overridableId,
    currentPage = _ref.currentPage,
    currentSize = _ref.currentSize,
    totalResults = _ref.totalResults,
    _onPageChange = _ref.onPageChange,
    options = _ref.options,
    maxTotalResults = _ref.maxTotalResults,
    props = _objectWithoutProperties(_ref, _excluded);
  var boundaryRangeCount = options.boundaryRangeCount;
  var siblingRangeCount = options.siblingRangeCount;
  var showEllipsis = options.showEllipsis;
  var showFirst = options.showFirst;
  var showLast = options.showLast;
  var showPrev = options.showPrev;
  var showNext = options.showNext;
  var size = options.size;
  var maxTotalPages = Math.floor(maxTotalResults / currentSize);
  var pages = Math.ceil(totalResults / currentSize);
  var totalDisplayedPages = Math.min(pages, maxTotalPages);
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  if (currentPage > pages) _onPageChange(pages);
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("Pagination.element", overridableId),
    currentPage: currentPage,
    currentSize: currentSize,
    totalResults: totalResults,
    options: options,
    onPageChange: _onPageChange
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Pagination, Object.assign({
    activePage: currentPage,
    totalPages: totalDisplayedPages,
    onPageChange: function onPageChange(_, _ref2) {
      var activePage = _ref2.activePage;
      return _onPageChange(activePage);
    },
    boundaryRange: boundaryRangeCount,
    siblingRange: siblingRangeCount,
    ellipsisItem: showEllipsis ? undefined : null,
    firstItem: showFirst ? undefined : null,
    lastItem: showLast ? undefined : null,
    prevItem: showPrev ? undefined : null,
    nextItem: showNext ? undefined : null,
    size: size
  }, props)));
};
Element$9.defaultProps = {
  options: {},
  overridableId: "",
  maxTotalResults: 10000
};
var PaginationComponent = Overridable__default["default"].component("Pagination", Pagination$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$6 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryPage: function updateQueryPage(page) {
      return dispatch(updateQueryPaginationPage(page));
    }
  };
};
var Pagination = reactRedux.connect(function (state) {
  return {
    currentPage: state.query.page,
    currentSize: state.query.size,
    loading: state.results.loading,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$6)(PaginationComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2022 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function ResultsGrid$1(_ref) {
  var loading = _ref.loading,
    totalResults = _ref.totalResults,
    results = _ref.results,
    resultsPerRow = _ref.resultsPerRow,
    overridableId = _ref.overridableId;
  return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
    condition: !loading && totalResults > 0
  }, /*#__PURE__*/React__default["default"].createElement(Element$8, {
    results: results,
    resultsPerRow: resultsPerRow,
    overridableId: overridableId
  }));
}
ResultsGrid$1.defaultProps = {
  resultsPerRow: 3,
  overridableId: ""
};
var GridItem = function GridItem(_ref2) {
  var result = _ref2.result,
    overridableId = _ref2.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsGrid.item", overridableId),
    result: result
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card, {
    fluid: true,
    href: "#".concat(result.id)
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Image, {
    src: result.imgSrc || "http://placehold.it/200"
  }), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Content, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Header, null, result.title), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Description, null, result.description))));
};
var Element$8 = function Element(_ref3) {
  var overridableId = _ref3.overridableId,
    results = _ref3.results,
    resultsPerRow = _ref3.resultsPerRow;
  var _useContext2 = React.useContext(AppContext),
    buildUID = _useContext2.buildUID;
  var _results = results.map(function (result, index) {
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react/no-array-index-key
      React__default["default"].createElement(GridItem, {
        key: index,
        result: result,
        overridableId: overridableId
      })
    );
  });
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsGrid.container", overridableId),
    results: results,
    resultsPerRow: resultsPerRow
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Group, {
    itemsPerRow: resultsPerRow
  }, _results));
};
Element$8.defaultProps = {
  resultsPerRow: 3,
  overridableId: ""
};
var ResultsGridComponent = Overridable__default["default"].component("ResultsGrid", ResultsGrid$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsGrid = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    results: state.results.data.hits
  };
})(ResultsGridComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2022 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function ResultsList$1(_ref) {
  var loading = _ref.loading,
    totalResults = _ref.totalResults,
    results = _ref.results,
    overridableId = _ref.overridableId;
  return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
    condition: !loading && totalResults > 0
  }, /*#__PURE__*/React__default["default"].createElement(Element$7, {
    results: results,
    overridableId: overridableId
  }));
}
ResultsList$1.defaultProps = {
  overridableId: ""
};
var ListItem = function ListItem(_ref2) {
  var result = _ref2.result,
    overridableId = _ref2.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsList.item", overridableId),
    result: result
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Item, {
    href: "#".concat(result.id)
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Item.Image, {
    size: "small",
    src: result.imgSrc || "http://placehold.it/200"
  }), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Item.Content, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Item.Header, null, result.title), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Item.Description, null, result.description))));
};
var Element$7 = function Element(_ref3) {
  var results = _ref3.results,
    overridableId = _ref3.overridableId;
  var _useContext2 = React.useContext(AppContext),
    buildUID = _useContext2.buildUID;
  var _results = results.map(function (result, index) {
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react/no-array-index-key
      React__default["default"].createElement(ListItem, {
        result: result,
        key: index,
        overridableId: overridableId
      })
    );
  });
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsList.container", overridableId),
    results: _results
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Item.Group, {
    divided: true,
    relaxed: true,
    link: true
  }, _results));
};
Element$7.defaultProps = {
  overridableId: ""
};
var ResultsListComponent = Overridable__default["default"].component("ResultsList", ResultsList$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsList = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    results: state.results.data.hits
  };
})(ResultsListComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2022 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function ResultsLoader$1(_ref) {
  var children = _ref.children,
    loading = _ref.loading,
    overridableId = _ref.overridableId;
  return loading ? /*#__PURE__*/React__default["default"].createElement(Element$6, {
    overridableId: overridableId
  }) : children;
}
ResultsLoader$1.defaultProps = {
  overridableId: ""
};
var Element$6 = function Element(_ref2) {
  var overridableId = _ref2.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsLoader.element", overridableId)
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Loader, {
    active: true,
    size: "huge",
    inline: "centered"
  }));
};
Element$6.defaultProps = {
  overridableId: ""
};
var ResultsLoaderComponent = Overridable__default["default"].component("ResultsLoader", ResultsLoader$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsLoader = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading
  };
})(ResultsLoaderComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2022 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function ResultsMultiLayout$1(_ref) {
  var loading = _ref.loading,
    totalResults = _ref.totalResults,
    currentLayout = _ref.currentLayout,
    overridableId = _ref.overridableId;
  return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
    condition: currentLayout != null && !loading && totalResults > 0
  }, /*#__PURE__*/React__default["default"].createElement(Element$5, {
    layout: currentLayout,
    overridableId: overridableId
  }));
}
ResultsMultiLayout$1.defaultProps = {
  currentLayout: null,
  overridableId: ""
};
var Element$5 = function Element(_ref2) {
  var layout = _ref2.layout,
    overridableId = _ref2.overridableId;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsMultiLayout.element", overridableId),
    layout: layout
  }, layout === "list" ? /*#__PURE__*/React__default["default"].createElement(ResultsList, {
    overridableId: overridableId
  }) : /*#__PURE__*/React__default["default"].createElement(ResultsGrid, {
    overridableId: overridableId
  }));
};
Element$5.defaultProps = {
  layout: "",
  overridableId: ""
};
var ResultsMultiLayoutComponent = Overridable__default["default"].component("ResultsMultiLayout", ResultsMultiLayout$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsMultiLayout = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    currentLayout: state.query.layout
  };
})(ResultsMultiLayoutComponent);

var ResultsPerPage$1 = /*#__PURE__*/function (_Component) {
  _inherits(ResultsPerPage, _Component);
  var _super = _createSuper(ResultsPerPage);
  function ResultsPerPage(props) {
    var _this;
    _classCallCheck(this, ResultsPerPage);
    _this = _super.call(this, props);
    _this.onChange = function (value) {
      var currentSize = _this.props.currentSize;
      if (value === currentSize) return;
      _this.updateQuerySize(value);
    };
    _this.options = props.values;
    _this.updateQuerySize = props.updateQuerySize;
    return _this;
  }
  _createClass(ResultsPerPage, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        loading = _this$props.loading,
        currentSize = _this$props.currentSize,
        totalResults = _this$props.totalResults,
        label = _this$props.label,
        overridableId = _this$props.overridableId,
        ariaLabel = _this$props.ariaLabel,
        selectOnNavigation = _this$props.selectOnNavigation;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: !loading && totalResults > 0 && currentSize !== -1
      }, label( /*#__PURE__*/React__default["default"].createElement(Element$4, {
        currentSize: currentSize,
        options: this.options,
        onValueChange: this.onChange,
        overridableId: overridableId,
        ariaLabel: ariaLabel,
        selectOnNavigation: selectOnNavigation
      })));
    }
  }]);
  return ResultsPerPage;
}(React.Component);
ResultsPerPage$1.defaultProps = {
  label: function label(cmp) {
    return cmp;
  },
  overridableId: "",
  ariaLabel: "Results per page",
  selectOnNavigation: false
};
var Element$4 = function Element(_ref) {
  var overridableId = _ref.overridableId,
    currentSize = _ref.currentSize,
    options = _ref.options,
    onValueChange = _ref.onValueChange,
    ariaLabel = _ref.ariaLabel,
    selectOnNavigation = _ref.selectOnNavigation;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("ResultsPerPage.element", overridableId),
    currentSize: currentSize,
    options: options,
    onValueChange: onValueChange,
    ariaLabel: ariaLabel,
    selectOnNavigation: selectOnNavigation
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Dropdown, {
    inline: true,
    compact: true,
    options: _options,
    value: currentSize,
    onChange: function onChange(e, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    },
    "aria-label": ariaLabel,
    selectOnNavigation: selectOnNavigation
  }));
};
Element$4.defaultProps = {
  ariaLabel: "Results per page",
  selectOnNavigation: false,
  overridableId: ""
};
var ResultsPerPageComponent = Overridable__default["default"].component("ResultsPerPage", ResultsPerPage$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$5 = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySize: function updateQuerySize(size) {
      return dispatch(updateQueryPaginationSize(size));
    }
  };
};
var ResultsPerPage = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    currentSize: state.query.size,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$5)(ResultsPerPageComponent);

var SearchBar$1 = /*#__PURE__*/function (_Component) {
  _inherits(SearchBar, _Component);
  var _super = _createSuper(SearchBar);
  function SearchBar(props) {
    var _this;
    _classCallCheck(this, SearchBar);
    _this = _super.call(this, props);
    _this.onInputChange = function (queryString) {
      _this.setState({
        currentValue: queryString
      });
    };
    _this.executeSearch = function () {
      var currentValue = _this.state.currentValue;
      _this.updateQueryString(currentValue);
    };
    _this.onBtnSearchClick = function () {
      _this.executeSearch();
    };
    _this.onKeyPress = function (event) {
      if (event.key === "Enter") {
        _this.executeSearch();
      }
    };
    _this.updateQueryString = props.updateQueryString;
    _this.state = {
      currentValue: props.queryString || ""
    };
    return _this;
  }
  _createClass(SearchBar, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        actionProps = _this$props.actionProps,
        autofocus = _this$props.autofocus,
        executeSearch = _this$props.executeSearch,
        onBtnSearchClick = _this$props.onBtnSearchClick,
        onInputChange = _this$props.onInputChange,
        onKeyPress = _this$props.onKeyPress,
        overridableId = _this$props.overridableId,
        placeholder = _this$props.placeholder,
        uiProps = _this$props.uiProps;
      var currentValue = this.state.currentValue;
      return /*#__PURE__*/React__default["default"].createElement(Element$3, {
        actionProps: actionProps,
        autofocus: autofocus,
        executeSearch: executeSearch || this.executeSearch,
        onBtnSearchClick: onBtnSearchClick || this.onBtnSearchClick,
        onInputChange: onInputChange || this.onInputChange,
        onKeyPress: onKeyPress || this.onKeyPress,
        overridableId: overridableId,
        placeholder: placeholder,
        queryString: currentValue,
        uiProps: uiProps
      });
    }
  }]);
  return SearchBar;
}(React.Component);
SearchBar$1.defaultProps = {
  actionProps: null,
  autofocus: false,
  executeSearch: null,
  onBtnSearchClick: null,
  onInputChange: null,
  onKeyPress: null,
  overridableId: "",
  placeholder: "",
  queryString: "",
  uiProps: null
};

// NOTE: Adding the key prop, will recreate the SearchBar in order to update
// state with the latest redux queryString value.
// https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key
var SearchBarUncontrolled = function SearchBarUncontrolled(props) {
  var queryString = props.queryString;
  return /*#__PURE__*/React__default["default"].createElement(SearchBar$1, Object.assign({
    key: queryString
  }, props));
};
SearchBarUncontrolled.defaultProps = {
  queryString: ""
};
var Element$3 = /*#__PURE__*/function (_Component2) {
  _inherits(Element, _Component2);
  var _super2 = _createSuper(Element);
  function Element() {
    _classCallCheck(this, Element);
    return _super2.apply(this, arguments);
  }
  _createClass(Element, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var autofocus = this.props.autofocus;
      if (autofocus && this.focusInput) {
        this.focusInput.focus();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props2 = this.props,
        actionProps = _this$props2.actionProps,
        onBtnSearchClick = _this$props2.onBtnSearchClick,
        onInputChange = _this$props2.onInputChange,
        onKeyPress = _this$props2.onKeyPress,
        overridableId = _this$props2.overridableId,
        placeholder = _this$props2.placeholder,
        queryString = _this$props2.queryString,
        uiProps = _this$props2.uiProps;
      var buildUID = this.context.buildUID;
      return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
        id: buildUID("SearchBar.element", overridableId),
        queryString: queryString,
        onBtnSearchClick: onBtnSearchClick,
        onInputChange: onInputChange,
        onKeyPress: onKeyPress,
        placeholder: placeholder,
        actionProps: actionProps,
        uiProps: uiProps
      }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Input, Object.assign({
        action: _objectSpread2({
          content: "Search",
          onClick: onBtnSearchClick
        }, actionProps),
        fluid: true
      }, uiProps, {
        placeholder: placeholder || "Type something",
        onChange: function onChange(_, _ref) {
          var value = _ref.value;
          onInputChange(value);
        },
        value: queryString,
        onKeyPress: onKeyPress,
        ref: function ref(input) {
          _this2.focusInput = input;
        }
      })));
    }
  }]);
  return Element;
}(React.Component);
Element$3.defaultProps = {
  actionProps: null,
  autofocus: false,
  onBtnSearchClick: null,
  onInputChange: null,
  onKeyPress: null,
  overridableId: "",
  placeholder: "",
  queryString: "",
  uiProps: null
};
Element$3.contextType = AppContext;
var SearchBarComponent = Overridable__default["default"].component("SearchBar", SearchBarUncontrolled);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$4 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryString: function updateQueryString$1(query) {
      return dispatch(updateQueryString(query));
    }
  };
};
var SearchBar = reactRedux.connect(function (state) {
  return {
    queryString: state.query.queryString
  };
}, mapDispatchToProps$4)(SearchBarComponent);

var Sort$1 = /*#__PURE__*/function (_Component) {
  _inherits(Sort, _Component);
  var _super = _createSuper(Sort);
  function Sort(props) {
    var _this;
    _classCallCheck(this, Sort);
    _this = _super.call(this, props);
    _this._computeValue = function (sortBy, sortOrder) {
      return sortOrder ? "".concat(sortBy, "-").concat(sortOrder) : sortBy;
    };
    _this.onChange = function (value) {
      var _this$props = _this.props,
        currentSortBy = _this$props.currentSortBy,
        currentSortOrder = _this$props.currentSortOrder;
      if (value === _this._computeValue(currentSortBy, currentSortOrder)) return;
      var selected = _this.options.find(function (option) {
        return option.value === value;
      });
      _this.updateQuerySorting(selected.sortBy, selected.sortOrder);
    };
    _this.options = props.values;
    _this.updateQuerySorting = props.updateQuerySorting;
    _this.options.forEach(function (option) {
      return option["value"] = _this._computeValue(option.sortBy, option.sortOrder);
    });
    return _this;
  }
  _createClass(Sort, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
        currentSortBy = _this$props2.currentSortBy,
        currentSortOrder = _this$props2.currentSortOrder,
        loading = _this$props2.loading,
        totalResults = _this$props2.totalResults,
        label = _this$props2.label,
        overridableId = _this$props2.overridableId,
        sortOrderDisabled = _this$props2.sortOrderDisabled,
        ariaLabel = _this$props2.ariaLabel,
        selectOnNavigation = _this$props2.selectOnNavigation;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: currentSortBy !== null && (sortOrderDisabled || currentSortBy !== null) && !loading && totalResults > 0
      }, label( /*#__PURE__*/React__default["default"].createElement(Element$2, {
        currentSortBy: currentSortBy,
        currentSortOrder: currentSortOrder,
        options: this.options,
        onValueChange: this.onChange,
        computeValue: this._computeValue,
        overridableId: overridableId,
        ariaLabel: ariaLabel,
        selectOnNavigation: selectOnNavigation
      })));
    }
  }]);
  return Sort;
}(React.Component);
Sort$1.defaultProps = {
  currentSortBy: null,
  currentSortOrder: null,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: "",
  sortOrderDisabled: false,
  ariaLabel: "Sort",
  selectOnNavigation: false
};
var Element$2 = function Element(_ref) {
  var overridableId = _ref.overridableId,
    currentSortBy = _ref.currentSortBy,
    currentSortOrder = _ref.currentSortOrder,
    options = _ref.options,
    onValueChange = _ref.onValueChange,
    computeValue = _ref.computeValue,
    ariaLabel = _ref.ariaLabel,
    selectOnNavigation = _ref.selectOnNavigation;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var selected = computeValue(currentSortBy, currentSortOrder);
  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("Sort.element", overridableId),
    options: options,
    currentSortBy: currentSortBy,
    currentSortOrder: currentSortOrder,
    onValueChange: onValueChange,
    ariaLabel: ariaLabel,
    selectOnNavigation: selectOnNavigation
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Dropdown, {
    selection: true,
    options: _options,
    value: selected,
    onChange: function onChange(e, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    },
    "aria-label": ariaLabel,
    selectOnNavigation: selectOnNavigation
  }));
};
Element$2.defaultProps = {
  currentSortBy: null,
  currentSortOrder: null,
  overridableId: "",
  ariaLabel: "Sort",
  selectOnNavigation: false
};
var SortComponent = Overridable__default["default"].component("Sort", Sort$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$3 = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySorting: function updateQuerySorting$1(sortBy, sortOrder) {
      return dispatch(updateQuerySorting(sortBy, sortOrder));
    }
  };
};
var Sort = reactRedux.connect(function (state) {
  return {
    currentSortBy: state.query.sortBy,
    currentSortOrder: state.query.sortOrder,
    loading: state.results.loading,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$3)(SortComponent);

var SortBy$1 = /*#__PURE__*/function (_Component) {
  _inherits(SortBy, _Component);
  var _super = _createSuper(SortBy);
  function SortBy(props) {
    var _this;
    _classCallCheck(this, SortBy);
    _this = _super.call(this, props);
    _this.onChange = function (value) {
      var currentSortBy = _this.props.currentSortBy;
      if (value === currentSortBy) return;
      _this.updateQuerySortBy(value);
    };
    _this.options = props.values;
    _this.updateQuerySortBy = props.updateQuerySortBy;
    return _this;
  }
  _createClass(SortBy, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        currentSortBy = _this$props.currentSortBy,
        loading = _this$props.loading,
        totalResults = _this$props.totalResults,
        label = _this$props.label,
        overridableId = _this$props.overridableId,
        ariaLabel = _this$props.ariaLabel,
        selectOnNavigation = _this$props.selectOnNavigation;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: currentSortBy !== null && !loading && totalResults > 0
      }, label( /*#__PURE__*/React__default["default"].createElement(Element$1, {
        currentSortBy: currentSortBy,
        options: this.options,
        onValueChange: this.onChange,
        overridableId: overridableId,
        ariaLabel: ariaLabel,
        selectOnNavigation: selectOnNavigation
      })));
    }
  }]);
  return SortBy;
}(React.Component);
SortBy$1.defaultProps = {
  currentSortBy: null,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: "",
  ariaLabel: "Sort Results By",
  selectOnNavigation: false
};
var Element$1 = function Element(_ref) {
  var overridableId = _ref.overridableId,
    currentSortBy = _ref.currentSortBy,
    options = _ref.options,
    onValueChange = _ref.onValueChange,
    ariaLabel = _ref.ariaLabel,
    selectOnNavigation = _ref.selectOnNavigation;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("SortBy.element", overridableId),
    options: options,
    currentSortBy: currentSortBy,
    onValueChange: onValueChange,
    ariaLabel: ariaLabel,
    selectOnNavigation: selectOnNavigation
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Dropdown, {
    selection: true,
    compact: true,
    options: _options,
    value: currentSortBy,
    onChange: function onChange(_, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    },
    "aria-label": ariaLabel,
    selectOnNavigation: selectOnNavigation
  }));
};
Element$1.defaultProps = {
  currentSortBy: null,
  overridableId: "",
  ariaLabel: "Sort Results By",
  selectOnNavigation: false
};
var SortByComponent = Overridable__default["default"].component("SortBy", SortBy$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$2 = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySortBy: function updateQuerySortBy$1(sortByValue) {
      return dispatch(updateQuerySortBy(sortByValue));
    }
  };
};
var SortBy = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    currentSortBy: state.query.sortBy
  };
}, mapDispatchToProps$2)(SortByComponent);

var SortOrder$1 = /*#__PURE__*/function (_Component) {
  _inherits(SortOrder, _Component);
  var _super = _createSuper(SortOrder);
  function SortOrder(props) {
    var _this;
    _classCallCheck(this, SortOrder);
    _this = _super.call(this, props);
    _this.onChange = function (value) {
      var currentSortOrder = _this.props.currentSortOrder;
      if (value === currentSortOrder) return;
      _this.updateQuerySortOrder(value);
    };
    _this.options = props.values;
    _this.updateQuerySortOrder = props.updateQuerySortOrder;
    return _this;
  }
  _createClass(SortOrder, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        currentSortOrder = _this$props.currentSortOrder,
        loading = _this$props.loading,
        totalResults = _this$props.totalResults,
        label = _this$props.label,
        overridableId = _this$props.overridableId,
        ariaLabel = _this$props.ariaLabel,
        selectOnNavigation = _this$props.selectOnNavigation;
      return /*#__PURE__*/React__default["default"].createElement(ShouldRender$1, {
        condition: currentSortOrder !== null && !loading && totalResults > 0
      }, label( /*#__PURE__*/React__default["default"].createElement(Element, {
        currentSortOrder: currentSortOrder,
        options: this.options,
        onValueChange: this.onChange,
        overridableId: overridableId,
        ariaLabel: ariaLabel,
        selectOnNavigation: selectOnNavigation
      })));
    }
  }]);
  return SortOrder;
}(React.Component);
SortOrder$1.defaultProps = {
  currentSortOrder: null,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: "",
  ariaLabel: "Sort Order",
  selectOnNavigation: false
};
var Element = function Element(_ref) {
  var overridableId = _ref.overridableId,
    currentSortOrder = _ref.currentSortOrder,
    options = _ref.options,
    onValueChange = _ref.onValueChange,
    ariaLabel = _ref.ariaLabel,
    selectOnNavigation = _ref.selectOnNavigation;
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("SortOrder.element", overridableId),
    options: options,
    currentSortOrder: currentSortOrder,
    onValueChange: onValueChange,
    ariaLabel: ariaLabel,
    selectOnNavigation: selectOnNavigation
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Dropdown, {
    selection: true,
    compact: true,
    options: _options,
    value: currentSortOrder,
    onChange: function onChange(_, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    },
    "aria-label": ariaLabel,
    selectOnNavigation: selectOnNavigation
  }));
};
Element.defaultProps = {
  currentSortOrder: null,
  overridableId: "",
  ariaLabel: "Sort Order",
  selectOnNavigation: false
};
var SortOrderComponent = Overridable__default["default"].component("SortOrder", SortOrder$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps$1 = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySortOrder: function updateQuerySortOrder$1(sortOrderValue) {
      return dispatch(updateQuerySortOrder(sortOrderValue));
    }
  };
};
var SortOrder = reactRedux.connect(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    currentSortOrder: state.query.sortOrder
  };
}, mapDispatchToProps$1)(SortOrderComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2020-2022 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ToggleComponent = function ToggleComponent(_ref) {
  var overridableId = _ref.overridableId,
    userSelectionFilters = _ref.userSelectionFilters,
    title = _ref.title,
    label = _ref.label,
    filterValue = _ref.filterValue,
    updateQueryFilters = _ref.updateQueryFilters;
  var _isChecked = function _isChecked(userSelectionFilters) {
    var isFilterActive = userSelectionFilters.filter(function (filter) {
      return filter[0] === filterValue[0];
    }).length > 0;
    return isFilterActive;
  };
  var onClick = function onClick() {
    updateQueryFilters(filterValue);
  };
  var _useContext = React.useContext(AppContext),
    buildUID = _useContext.buildUID;
  var isChecked = _isChecked(userSelectionFilters);
  return /*#__PURE__*/React__default["default"].createElement(Overridable__default["default"], {
    id: buildUID("SearchFilters.Toggle.element", overridableId),
    title: title,
    label: label,
    filterValue: filterValue,
    userSelectionFilters: userSelectionFilters,
    updateQueryFilters: updateQueryFilters
  }, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Content, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Header, null, title)), /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Card.Content, null, /*#__PURE__*/React__default["default"].createElement(semanticUiReact.Checkbox, {
    toggle: true,
    label: label,
    onClick: onClick,
    checked: isChecked
  }))));
};
ToggleComponent.defaultProps = {
  overridableId: ""
};
var ToggleComponent$1 = Overridable__default["default"].component("SearchFilters.Toggle", ToggleComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
  return {
    updateQueryFilters: function updateQueryFilters$1(filter) {
      return dispatch(updateQueryFilters(filter));
    }
  };
};
var Toggle = reactRedux.connect(function (state) {
  return {
    userSelectionFilters: state.query.filters
  };
}, mapDispatchToProps)(ToggleComponent$1);

var onQueryChanged = function onQueryChanged(payload) {
  var evt = new CustomEvent("queryChanged", {
    detail: payload
  });
  window.dispatchEvent(evt);
};

exports.ActiveFilters = ActiveFilters;
exports.AppContext = AppContext;
exports.AutocompleteSearchBar = AutocompleteSearchBar;
exports.BucketAggregation = BucketAggregation;
exports.Count = Count;
exports.ESRequestSerializer = ESRequestSerializer;
exports.ESResponseSerializer = ESResponseSerializer;
exports.ESSearchApi = ESSearchApi;
exports.EmptyResults = EmptyResults;
exports.Error = Error$1;
exports.InvenioRecordsResourcesRequestSerializer = InvenioRecordsResourcesRequestSerializer;
exports.InvenioRequestSerializer = InvenioRequestSerializer;
exports.InvenioResponseSerializer = InvenioResponseSerializer;
exports.InvenioSearchApi = InvenioSearchApi;
exports.InvenioSuggestionApi = InvenioSuggestionApi;
exports.LayoutSwitcher = LayoutSwitcher;
exports.Pagination = Pagination;
exports.ReactSearchKit = ReactSearchKit$1;
exports.RequestCancelledError = RequestCancelledError;
exports.ResultsGrid = ResultsGrid;
exports.ResultsList = ResultsList;
exports.ResultsLoader = ResultsLoader;
exports.ResultsMultiLayout = ResultsMultiLayout;
exports.ResultsPerPage = ResultsPerPage;
exports.SearchBar = SearchBar;
exports.Sort = Sort;
exports.SortBy = SortBy;
exports.SortOrder = SortOrder;
exports.Toggle = Toggle;
exports.UrlHandlerApi = UrlHandlerApi;
exports.UrlParamValidator = UrlParamValidator;
exports.buildUID = buildUID;
exports.createStoreWithConfig = createStoreWithConfig;
exports.onQueryChanged = onQueryChanged;
exports.withState = withState;
//# sourceMappingURL=index.js.map
